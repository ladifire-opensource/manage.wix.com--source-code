import { parseLeanSchemaRef } from '..';
export function schemaSerializer(rootSchema, depSchemas, converterSets) {
    if (depSchemas === void 0) { depSchemas = {}; }
    return function serialize(json, converterType) {
        if (json === void 0) { json = {}; }
        return transformSchema(rootSchema, json);
        function transformSchema(schema, payload) {
            var result = {};
            Object.entries(payload).forEach(function (_a) {
                var _b, _c, _d;
                var key = _a[0], val = _a[1];
                var renderedSchemaName = schema[key];
                var _e = parseLeanSchemaRef(renderedSchemaName), schemaName = _e.schemaName, schemaType = _e.schemaType;
                var isMap = schemaType === 'Map';
                var isRepeatable = (_d = (_c = (_b = getConverter(schemaName)) === null || _b === void 0 ? void 0 : _b.checkRepetable) === null || _c === void 0 ? void 0 : _c.call(_b, val)) !== null && _d !== void 0 ? _d : Array.isArray(val);
                var parsedValue;
                if (isRepeatable) {
                    parsedValue = val.map(function (v) { return applyField(v, schemaName); });
                }
                else if (isMap) {
                    parsedValue = applyFieldOnMap(val, schemaName);
                }
                else {
                    parsedValue = applyField(val, schemaName);
                }
                result[key] = parsedValue;
            });
            return result;
        }
        function applyField(val, schemaOrSerializer) {
            if (!schemaOrSerializer) {
                return val;
            }
            var maybeSchema = depSchemas[schemaOrSerializer];
            var maybeConverter = getConverter(schemaOrSerializer);
            if (maybeConverter) {
                return getConverter(schemaOrSerializer).transfrom(val);
            }
            else if (maybeSchema) {
                return transformSchema(maybeSchema, val);
            }
            throw new Error(schemaOrSerializer + " is neither schema nor serializable type");
        }
        function getConverter(name) {
            var _a;
            return (_a = converterSets[name]) === null || _a === void 0 ? void 0 : _a[converterType];
        }
        function applyFieldOnMap(val, sanitizedSchemaOrSerializer) {
            return Object.entries(val).reduce(function (acc, _a) {
                var propertyName = _a[0], value = _a[1];
                acc[propertyName] = applyField(value, sanitizedSchemaOrSerializer);
                return acc;
            }, {});
        }
    };
}
//# sourceMappingURL=serializer.js.map