import { fromValue, fromString } from 'long';
var cloneDeep = require('lodash.clonedeep');
export var fromJson = function (typeName, payload, pathInPayload) {
    var clonedPayload = cloneDeep(payload);
    serializer[typeName].fromJson(clonedPayload, pathInPayload);
    return clonedPayload;
};
export var toJson = function (typeName, payload, pathInPayload) {
    var clonedPayload = cloneDeep(payload);
    serializer[typeName].toJson(clonedPayload, pathInPayload);
    return clonedPayload;
};
export var batchFromJson = function (payload, serializationRequests) {
    var clonedPayload = cloneDeep(payload);
    serializationRequests.forEach(function (serializationRequest) {
        serializer[serializationRequest.typeName].fromJson(clonedPayload, serializationRequest.pathInPayload);
    });
    return clonedPayload;
};
export var batchToJson = function (payload, serializationRequests) {
    var clonedPayload = cloneDeep(payload);
    serializationRequests.forEach(function (serializationRequest) {
        serializer[serializationRequest.typeName].toJson(clonedPayload, serializationRequest.pathInPayload);
    });
    return clonedPayload;
};
export var NULL_VALUE_SERIALIZATION_KEY = 'google.protobuf.NullValue';
export var DURATION_SERIALIZATION_KEY = 'google.protobuf.Duration';
export var TIMESTAMP_SERIALIZATION_KEY = 'google.protobuf.Timestamp';
export var FIELD_MASK_SERIALIZATION_KEY = 'google.protobuf.FieldMask';
export var FIELD_MASK_ARRAY_SERIALIZATION_KEY = 'google.protobuf.FieldMaskArray';
export var INT_64_SERIALIZATION_KEY = 'int64';
export var FIXED_64_SERIALIZATION_KEY = 'fixed64';
export var SFIXED_64_SERIALIZATION_KEY = 'sfixed64';
export var UINT_64_SERIALIZATION_KEY = 'uint64';
export var SINT_64_SERIALIZATION_KEY = 'sint64';
export var UINT_64_VALUE_SERIALIZATION_KEY = 'google.protobuf.UInt64Value';
export var BYTES_SERIALIZATION_KEY = 'bytes';
export var INT_64_VALUE_SERIALIZATION_KEY = 'google.protobuf.Int64Value';
var typeTransformer = function (jsonSerializer, jsonDeserializer) {
    return {
        toJson: function (payload, pathInPayload) {
            return updatePathRecursively(payload, pathInPayload, jsonSerializer);
        },
        fromJson: function (payload, pathInPayload) {
            return updatePathRecursively(payload, pathInPayload, jsonDeserializer);
        },
    };
};
var jsonDeserializeLong = function (longAsString) { return (longAsString !== undefined ? fromValue(longAsString) : undefined); };
var jsonSerializeLong = function (longObject) {
    return longObject !== undefined ? longObject.toString() : undefined;
};
var longTransformer = typeTransformer(jsonSerializeLong, jsonDeserializeLong);
var jsonSerializeTimestamp = function (dateObject) {
    return dateObject ? dateObject.toISOString() : undefined;
};
var jsonDeserializeTimestamp = function (dateString) {
    return dateString ? new Date(Date.parse(dateString.toString())) : undefined;
};
var jsonSerializeNullValue = function () { return null; };
var jsonDeserializeNullValue = function () { return null; };
var jsonSerializeFieldMask = function (fieldMaskObject) {
    return fieldMaskObject;
};
var jsonDeserializeFieldMask = function (fieldMaskString) { return fieldMaskString; };
var jsonSerializeFieldMaskArray = function (fieldMaskObject) {
    return fieldMaskObject && Array.isArray(fieldMaskObject)
        ? fieldMaskObject.join(',')
        : undefined;
};
var jsonDeserializeFieldMaskArray = function (fieldMaskString) {
    return fieldMaskString ? fieldMaskString.split(',') : undefined;
};
var jsonDeserializeBytes = function (bytes64bitEncodedString) {
    var asCharCode = function (c) { return c.charCodeAt(0); };
    var decode = function (chars) { return Uint8Array.from(atob(chars), asCharCode); };
    return decode(bytes64bitEncodedString);
};
var jsonSerializeBytes = function (bytesArray) {
    var output = [];
    for (var i = 0, length_1 = bytesArray.length; i < length_1; i++) {
        output.push(String.fromCharCode(bytesArray[i]));
    }
    return btoa(output.join(''));
};
var jsonSerializeDuration = function (durationObject) {
    if (durationObject &&
        durationObject.seconds !== undefined &&
        durationObject.nanos !== undefined) {
        var nanosString = durationObject.nanos.toString().length < 9
            ? '000000000'.substr(0, 9 - durationObject.nanos.toString().length) +
                durationObject.nanos.toString()
            : durationObject.nanos.toString();
        return durationObject.seconds.toString() + "." + nanosString + "s";
    }
    return undefined;
};
var jsonDeserializeDuration = function (durationString) {
    return durationString
        ? {
            seconds: fromString(durationString.substr(0, durationString.indexOf('.'))),
            nanos: Number.parseInt(durationString.substr(durationString.indexOf('.') + 1, durationString.length - 1), 10),
        }
        : undefined;
};
/**
 * traverse the payload recursively and apply the transformation on the end of the path.
 * in case we have an array as part of the path we assume the array elements are all of the same type and we apply the
 * transformation on all the path continuations of all the array elements
 * @param payload
 * @param pathToUpdate
 * @param applyTransformation
 */
var updatePathRecursively = function (payload, pathToUpdate, applyTransformation) {
    if (pathToUpdate.length === 1) {
        // recursion end condition
        if (payload !== undefined && payload !== null) {
            // all the fields are optional so only if we have an object we will update it.
            var transformedPayload = applyTransformation(payload[pathToUpdate[0]]);
            if (transformedPayload !== undefined && transformedPayload !== null) {
                payload[pathToUpdate[0]] = transformedPayload;
            }
        }
    }
    else {
        // go down one level deep in the recursion
        if (payload !== undefined && payload !== null) {
            // all the fields are optional so only if we have an object we will continue the recursion.
            var currentPayloadSubTree = payload[pathToUpdate[0]];
            if (Array.isArray(currentPayloadSubTree)) {
                // traverse arrays
                currentPayloadSubTree.forEach(function (objectArrayElement) {
                    return updatePathRecursively(objectArrayElement, pathToUpdate.slice(1), applyTransformation);
                });
            }
            else {
                // traverse object with the rest of the path
                updatePathRecursively(currentPayloadSubTree, pathToUpdate.slice(1), applyTransformation);
            }
        }
    }
};
var serializer = {};
serializer[NULL_VALUE_SERIALIZATION_KEY] = typeTransformer(jsonSerializeNullValue, jsonDeserializeNullValue);
serializer[DURATION_SERIALIZATION_KEY] = typeTransformer(jsonSerializeDuration, jsonDeserializeDuration);
serializer[INT_64_VALUE_SERIALIZATION_KEY] = longTransformer;
serializer[INT_64_SERIALIZATION_KEY] = longTransformer;
serializer[FIXED_64_SERIALIZATION_KEY] = longTransformer;
serializer[SFIXED_64_SERIALIZATION_KEY] = longTransformer;
serializer[UINT_64_SERIALIZATION_KEY] = longTransformer;
serializer[SINT_64_SERIALIZATION_KEY] = longTransformer;
serializer[UINT_64_VALUE_SERIALIZATION_KEY] = longTransformer;
serializer[TIMESTAMP_SERIALIZATION_KEY] = typeTransformer(jsonSerializeTimestamp, jsonDeserializeTimestamp);
serializer[FIELD_MASK_SERIALIZATION_KEY] = typeTransformer(jsonSerializeFieldMask, jsonDeserializeFieldMask);
serializer[FIELD_MASK_ARRAY_SERIALIZATION_KEY] = typeTransformer(jsonSerializeFieldMaskArray, jsonDeserializeFieldMaskArray);
serializer[BYTES_SERIALIZATION_KEY] = typeTransformer(jsonSerializeBytes, jsonDeserializeBytes);
//# sourceMappingURL=index.js.map