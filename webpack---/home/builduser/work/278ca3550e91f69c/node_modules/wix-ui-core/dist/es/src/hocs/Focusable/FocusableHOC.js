import { __assign, __extends } from "tslib";
import * as React from 'react';
import hoistNonReactMethods from 'hoist-non-react-methods';
import { getDisplayName } from '../utils';
import { st, classes } from './Focusable.st.css';
import { isStatelessComponent } from '../../utils';
/**
 * Assigned the given propTypes to the given class.
 *
 * This is a hack because since Yoshi3, with babel-preset-yoshi,
 * the babel-plugin-transform-react-remove-prop-types is enabled and removes propTypes.
 *
 * So if we simply do FocusableHOC.propTypes = Component.propTypes, it is being stripped away.
 *
 * This later becomes a problem if another component defines:
 * <code>
 * Comp.propTypes = {
 *   prop1: SomeFocusableComp.propTypes.prop1
 * }
 * </code>
 */
var assignPropTypesHack = function (targetClass, propTypes) {
    targetClass.propTypes = propTypes;
};
/**
 * Singleton for managing current input method (keyboard or mouse).
 */
var inputMethod = new (/** @class */ (function () {
    function class_1() {
        var _this = this;
        // Default is keyboard in case an element is focused programmatically.
        this.method = 'keyboard';
        this.subscribers = new Map();
        this.subscribe = function (target, callback) {
            return _this.subscribers.set(target, callback);
        };
        this.unsubscribe = function (target) { return _this.subscribers.delete(target); };
        /**
         * Is the current input method `keyboard`. if `false` is means it is `mouse`
         */
        this.isKeyboard = function () { return _this.method === 'keyboard'; };
        if (typeof window !== 'undefined') {
            window.addEventListener('mousedown', function () { return _this.setMethod('mouse'); });
            window.addEventListener('keydown', function () { return _this.setMethod('keyboard'); });
            // We need to listen on keyUp, in case a TAB is made from the browser's address-bar,
            // so the keyDown is not fired, only the keyUp.
            window.addEventListener('keyup', function () { return _this.setMethod('keyboard'); });
        }
    }
    class_1.prototype.setMethod = function (method) {
        if (method !== this.method) {
            this.method = method;
            this.subscribers.forEach(function (f) { return f(); });
        }
    };
    return class_1;
}()))();
/*
 * TODO: Consider adding 'disabled' state to this HOC, since:
 * - When component is focused and then it becomes disabled, then the focus needs to be blured.
 *
 * TODO: Consider using [Recompose](https://github.com/acdlite/recompose/tree/master/src/packages/recompose) to do:
 *  - the static hoisting
 *  - set displayName
 */
export var withFocusable = function (Component) {
    var FocusableHOC = /** @class */ (function (_super) {
        __extends(FocusableHOC, _super);
        function FocusableHOC() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.focusedByMouse = false;
            _this.wrappedComponentRef = null;
            _this.state = {
                focus: false,
                focusVisible: false,
            };
            _this.focus = function () {
                if (_this.wrappedComponentRef && _this.wrappedComponentRef.focus) {
                    _this.wrappedComponentRef.focus();
                }
            };
            _this.markAsFocused = function () {
                _this.setState({ focus: true, focusVisible: inputMethod.isKeyboard() });
                inputMethod.subscribe(_this, function () {
                    if (inputMethod.isKeyboard()) {
                        _this.setState({ focusVisible: true });
                    }
                });
            };
            _this.markAsBlurred = function () {
                inputMethod.unsubscribe(_this);
                _this.setState({ focus: false, focusVisible: false });
            };
            _this.onFocus = function (event) {
                var onFocus = _this.props.onFocus;
                onFocus
                    ? onFocus(event, {
                        blur: _this.markAsBlurred,
                        focus: _this.markAsFocused,
                    })
                    : _this.markAsFocused();
            };
            _this.onBlur = function (event) {
                var onBlur = _this.props.onBlur;
                onBlur
                    ? onBlur(event, { blur: _this.markAsBlurred, focus: _this.markAsFocused })
                    : _this.markAsBlurred();
            };
            return _this;
        }
        FocusableHOC.prototype.componentWillUnmount = function () {
            inputMethod.unsubscribe(this);
        };
        FocusableHOC.prototype.componentDidUpdate = function (prevProps) {
            /*
              in case when button was focused and then become disabled,
              we need to trigger blur logic and remove all listers, as disabled button
              do not trigger onFocus and onBlur events
            */
            var isFocused = this.state.focus || this.state.focusVisible;
            var isBecomeDisabled = !prevProps.disabled && this.props.disabled;
            if (isFocused && isBecomeDisabled) {
                this.onBlur({});
            }
        };
        FocusableHOC.prototype.render = function () {
            var _this = this;
            var reference = isStatelessComponent(Component)
                ? undefined
                : function (ref) { return (_this.wrappedComponentRef = ref); };
            return (React.createElement(Component, __assign({}, this.props, { ref: reference, focusableOnFocus: this.onFocus, focusableOnBlur: this.onBlur, className: st(classes.root, {
                    focus: this.state.focus,
                    'focus-visible': this.state.focusVisible,
                }, this.props.className) })));
        };
        FocusableHOC.displayName = getDisplayName(Component);
        FocusableHOC.defaultProps = Component.defaultProps;
        return FocusableHOC;
    }(React.Component));
    assignPropTypesHack(FocusableHOC, Component.propTypes);
    return isStatelessComponent(Component)
        ? FocusableHOC
        : hoistNonReactMethods(FocusableHOC, Component, {
            delegateTo: function (c) { return c.wrappedComponentRef; },
            hoistStatics: true,
        });
};
//# sourceMappingURL=FocusableHOC.js.map