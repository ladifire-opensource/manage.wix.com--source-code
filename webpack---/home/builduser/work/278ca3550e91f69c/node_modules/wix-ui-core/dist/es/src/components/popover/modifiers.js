import { __assign } from "tslib";
var getUnit = function (value) {
    if (typeof value === 'string') {
        return value;
    }
    return value + "px";
};
var calculateOffset = function (_a) {
    var moveBy = _a.moveBy, _b = _a.placement, placement = _b === void 0 ? '' : _b;
    /*
     * For `right` and `left` placements, we need to flip the `x` and `y` values as Popper.JS will use
     * the first value for the main axis. As per Popper.js docs:
     *
     *   if the placement is top or bottom, the length will be the width. In case of left or right, it
     *   will be the height.
     *
     */
    if (placement.includes('right') || placement.includes('left')) {
        return (moveBy ? moveBy.y : 0) + "px, " + (moveBy ? moveBy.x : 0) + "px";
    }
    return (moveBy ? moveBy.x : 0) + "px, " + (moveBy ? moveBy.y : 0) + "px";
};
var resolveWidth = function (_a) {
    var width = _a.width, minWidth = _a.minWidth, dynamicWidth = _a.dynamicWidth, referenceWidth = _a.referenceWidth;
    return {
        minWidth: dynamicWidth ? referenceWidth + "px" : getUnit(minWidth),
        width: width || 'auto',
    };
};
export var createModifiers = function (_a) {
    var width = _a.width, moveBy = _a.moveBy, appendTo = _a.appendTo, shouldAnimate = _a.shouldAnimate, flip = _a.flip, fixed = _a.fixed, placement = _a.placement, isTestEnv = _a.isTestEnv, minWidth = _a.minWidth, dynamicWidth = _a.dynamicWidth;
    var preventOverflow = !fixed;
    var modifiers = {
        offset: {
            offset: calculateOffset({ moveBy: moveBy, placement: placement }),
        },
        computeStyle: {
            gpuAcceleration: !shouldAnimate,
        },
        flip: {
            enabled: typeof flip !== 'undefined' ? flip : !moveBy,
        },
        preventOverflow: {
            enabled: preventOverflow,
        },
        hide: {
            enabled: preventOverflow,
        },
    };
    if (dynamicWidth || minWidth || width) {
        modifiers.setPopperWidth = {
            enabled: true,
            order: 840,
            fn: function (data) {
                var referenceWidth = data.offsets.reference.width;
                data.styles = __assign(__assign({}, data.styles), resolveWidth({
                    width: width,
                    referenceWidth: referenceWidth,
                    minWidth: minWidth,
                    dynamicWidth: dynamicWidth,
                }));
                return data;
            },
        };
    }
    if (isTestEnv) {
        modifiers.computeStyle = { enabled: false };
    }
    if (appendTo) {
        modifiers.preventOverflow = __assign(__assign({}, modifiers.preventOverflow), { boundariesElement: appendTo });
    }
    return modifiers;
};
//# sourceMappingURL=modifiers.js.map