import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["dataHook", "gap", "children", "className", "style", "inline", "direction", "align", "verticalAlign", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "color", "backgroundColor", "border", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "data-hook", "flexDirection", "justifyContent", "alignItems"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useMemo } from 'react';
import PropTypes from 'prop-types';
import { st, classes, vars } from './Box.st.css';
import { stVars as spacingStVars } from '../Foundation/stylable/spacing.st.css';
import { stVars as colorsStVars } from '../Foundation/stylable/colors.st.css';
import { filterObject } from '../utils/filterObject';
import { directions, horizontalAlignmentValues, spacingValues, verticalAlignmentValues } from './constants';
/** In case the value is a number, it's multiplied by the defined spacing unit.
 *  Otherwise - there are three options:
 *   1. A Spacing Token - SP1, SP2, etc. - where the number is multiplied by the spacing unit.
 *   2. A predefined spacing value with semantic name (tiny, small, etc.)
 *   3. Space-separated values that are represented by a string (for example: "3px 3px")
 * */

export var formatSingleSpacingValue = function formatSingleSpacingValue(value) {
  if (value !== undefined) {
    return formatSpacingValue(value);
  }
};
export var formatComplexSpacingValue = function formatComplexSpacingValue(value) {
  if (value !== undefined) {
    return value.toString().split(' ').map(function (size) {
      return formatSpacingValue(size);
    }).join(' ');
  }
};

var formatSpacingValue = function formatSpacingValue(value) {
  if (isFinite(value)) {
    return "".concat(value * parseInt(spacingStVars.Spacing), "px");
  }

  return spacingStVars[value] || spacingValues[value] || "".concat(value);
};

var formatSizeValue = function formatSizeValue(value) {
  if (typeof value !== 'undefined') return isFinite(value) ? "".concat(value, "px") : "".concat(value);
};

var Box = function Box(_ref) {
  var dataHook = _ref.dataHook,
      gap = _ref.gap,
      children = _ref.children,
      className = _ref.className,
      style = _ref.style,
      inline = _ref.inline,
      direction = _ref.direction,
      align = _ref.align,
      verticalAlign = _ref.verticalAlign,
      padding = _ref.padding,
      paddingTop = _ref.paddingTop,
      paddingRight = _ref.paddingRight,
      paddingBottom = _ref.paddingBottom,
      paddingLeft = _ref.paddingLeft,
      margin = _ref.margin,
      marginTop = _ref.marginTop,
      marginRight = _ref.marginRight,
      marginBottom = _ref.marginBottom,
      marginLeft = _ref.marginLeft,
      minWidth = _ref.minWidth,
      maxWidth = _ref.maxWidth,
      width = _ref.width,
      minHeight = _ref.minHeight,
      maxHeight = _ref.maxHeight,
      height = _ref.height,
      color = _ref.color,
      backgroundColor = _ref.backgroundColor,
      border = _ref.border,
      borderColor = _ref.borderColor,
      borderTopColor = _ref.borderTopColor,
      borderRightColor = _ref.borderRightColor,
      borderBottomColor = _ref.borderBottomColor,
      borderLeftColor = _ref.borderLeftColor,
      dataHookByKebabCase = _ref['data-hook'],
      flexDirection = _ref.flexDirection,
      justifyContent = _ref.justifyContent,
      alignItems = _ref.alignItems,
      nativeStyles = _objectWithoutProperties(_ref, _excluded);

  var complexSpacingValues = useMemo(function () {
    return Object.entries({
      padding: padding,
      margin: margin
    }).reduce(function (accu, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          key = _ref3[0],
          value = _ref3[1];

      return _objectSpread(_objectSpread({}, accu), {}, _defineProperty({}, key, formatComplexSpacingValue(value)));
    }, {});
  }, [padding, margin]);
  var singleSpacingValues = useMemo(function () {
    return Object.entries({
      paddingTop: paddingTop,
      paddingRight: paddingRight,
      paddingBottom: paddingBottom,
      paddingLeft: paddingLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      marginLeft: marginLeft
    }).reduce(function (accu, _ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          key = _ref5[0],
          value = _ref5[1];

      return _objectSpread(_objectSpread({}, accu), {}, _defineProperty({}, key, formatSingleSpacingValue(value)));
    }, {});
  }, [paddingTop, paddingRight, paddingBottom, paddingLeft, marginTop, marginRight, marginBottom, marginLeft]);
  var sizeValues = useMemo(function () {
    return Object.entries({
      minWidth: minWidth,
      maxWidth: maxWidth,
      width: width,
      minHeight: minHeight,
      maxHeight: maxHeight,
      height: height
    }).reduce(function (accu, _ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          key = _ref7[0],
          value = _ref7[1];

      return _objectSpread(_objectSpread({}, accu), {}, _defineProperty({}, key, formatSizeValue(value)));
    }, {});
  }, [minWidth, maxWidth, width, minHeight, maxHeight, height]);
  var rootClassNames = st(classes.root, {
    inline: inline,
    direction: direction,
    alignItems: align,
    justifyContent: verticalAlign
  }, className);

  var rootStyles = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, style), singleSpacingValues), complexSpacingValues), sizeValues), {}, {
    // Styling
    color: colorsStVars[color] || color,
    backgroundColor: colorsStVars[backgroundColor] || backgroundColor,
    border: border
  }, borderColor && {
    borderColor: colorsStVars[borderColor] || borderColor
  }), borderTopColor && {
    borderTopColor: colorsStVars[borderTopColor] || borderTopColor
  }), borderRightColor && {
    borderRightColor: colorsStVars[borderRightColor] || borderRightColor
  }), borderBottomColor && {
    borderBottomColor: colorsStVars[borderBottomColor] || borderBottomColor
  }), borderLeftColor && {
    borderLeftColor: colorsStVars[borderLeftColor] || borderLeftColor
  }), nativeStyles), {}, _defineProperty({}, vars['gap'], formatSingleSpacingValue(gap) || 0)); // Filter undefined values


  var rootStylesFiltered = filterObject(rootStyles, function (key, value) {
    return typeof value !== 'undefined';
  });
  return /*#__PURE__*/React.createElement("div", {
    "data-hook": dataHook,
    className: rootClassNames,
    style: rootStylesFiltered
  }, children);
};

Box.displayName = 'Box';
Box.propTypes = {
  /** Allows to render any component as a child item */
  children: PropTypes.node,

  /** Define styles through a classname */
  className: PropTypes.string,

  /** Defines if the box behaves as an inline element */
  inline: PropTypes.bool,

  /** Defines how the children are ordered (horizontally or vertically) */
  direction: PropTypes.oneOf(Object.keys(directions)),

  /** Defines how the children are aligned according to the X axis */
  align: PropTypes.oneOf(Object.keys(horizontalAlignmentValues)),

  /** Defines how the children are aligned according to the Y axis */
  verticalAlign: PropTypes.oneOf(Object.keys(verticalAlignmentValues)),

  /** Sets the gaps/gutters between flex items.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) */
  gap: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets padding on all sides.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a string of space-separated values ("3px 3px") */
  padding: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets padding on the top.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  paddingTop: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets padding on the right.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  paddingRight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets padding on the bottom.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  paddingBottom: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets padding on the left.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  paddingLeft: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets margin on all sides.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a string of space-separated values ("3px 3px") */
  margin: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets margin on the top.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  marginTop: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets margin on the right.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  marginRight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets margin on the bottom.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  marginBottom: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets margin on the left.
   * Accepts a numeric value (multiplied by spacing unit), predefined spacing value (tiny, small, etc.)
   * a spacing token (SP1, SP2, etc.) or a value in pixels */
  marginLeft: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the minimum width of the box in pixels */
  minWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the maximum width of the box in pixels */
  maxWidth: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the width of the box in pixels */
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the minimum height of the box in pixels */
  minHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the maximum height of the box in pixels */
  maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets the height of the box in pixels */
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Sets a text color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  color: PropTypes.string,

  /** Sets a background color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  backgroundColor: PropTypes.string,

  /** Sets a border color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  borderColor: PropTypes.string,

  /** Sets a border top color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  borderTopColor: PropTypes.string,

  /** Sets a border right color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  borderRightColor: PropTypes.string,

  /** Sets a border bottom color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  borderBottomColor: PropTypes.string,

  /** Sets a border left color by a key from the color palette or natively supported value (Hex, RGB, etc.) */
  borderLeftColor: PropTypes.string,

  /** Accepts HTML attributes that can be used in the tests */
  dataHook: PropTypes.string
};
Box.defaultProps = {
  direction: 'horizontal',
  inline: false
};
export default Box;