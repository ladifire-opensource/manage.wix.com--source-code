function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as utils from './utils';
import IntlMessageFormat from 'intl-messageformat';

function getDefaults() {
  return {
    memoize: true,
    memoizeFallback: false,
    bindI18n: '',
    bindI18nStore: '',
    parseErrorHandler: function parseErrorHandler(err, key, res) {
      return res;
    }
  };
}

var ICU = /*#__PURE__*/function () {
  function ICU(options) {
    this.type = 'i18nFormat';
    this.mem = {};
    this.init(null, options);
  }

  var _proto = ICU.prototype;

  _proto.init = function init(i18next, options) {
    var _this = this;

    var i18nextOptions = i18next && i18next.options && i18next.options.i18nFormat || {};
    this.options = utils.defaults(i18nextOptions, options, this.options || {}, getDefaults());
    this.formats = this.options.formats;

    if (i18next) {
      var _this$options = this.options,
          bindI18n = _this$options.bindI18n,
          bindI18nStore = _this$options.bindI18nStore,
          memoize = _this$options.memoize;
      i18next.IntlMessageFormat = IntlMessageFormat;
      i18next.ICU = this;

      if (memoize) {
        if (bindI18n) {
          i18next.on(bindI18n, function () {
            return _this.clearCache();
          });
        }

        if (bindI18nStore) {
          i18next.store.on(bindI18nStore, function () {
            return _this.clearCache();
          });
        }
      }
    }

    if (this.options.localeData) {
      if (Object.prototype.toString.apply(this.options.localeData) === '[object Array]') {
        this.options.localeData.forEach(function (ld) {
          return _this.addLocaleData(ld);
        });
      } else {
        this.addLocaleData(this.options.localeData);
      }
    }
  };

  _proto.addLocaleData = function addLocaleData(data) {
    var locales = Object.prototype.toString.apply(data) === '[object Array]' ? data : [data];
    locales.forEach(function (localeData) {
      if (localeData && localeData.locale) {
        IntlMessageFormat.__addLocaleData(localeData); // IntlRelativeFormat.__addLocaleData(localeData);

      }
    });
  };

  _proto.addUserDefinedFormats = function addUserDefinedFormats(formats) {
    this.formats = this.formats ? _objectSpread(_objectSpread({}, this.formats), formats) : formats;
  };

  _proto.parse = function parse(res, options, lng, ns, key, info) {
    var hadSuccessfulLookup = info && info.resolved && info.resolved.res;
    var memKey = this.options.memoize && lng + "." + ns + "." + key.replace(/\./g, '###');
    var fc;

    if (this.options.memoize) {
      fc = utils.getPath(this.mem, memKey);
    }

    try {
      if (!fc) {
        fc = new IntlMessageFormat(res, lng, this.formats);
        if (this.options.memoize && (this.options.memoizeFallback || !info || hadSuccessfulLookup)) utils.setPath(this.mem, memKey, fc);
      }

      return fc.format(options);
    } catch (err) {
      return this.options.parseErrorHandler(err, key, res, options);
    }
  };

  _proto.addLookupKeys = function addLookupKeys(finalKeys) {
    // no additional keys needed for select or plural
    // so there is no need to add keys to that finalKeys array
    return finalKeys;
  };

  _proto.clearCache = function clearCache() {
    this.mem = {};
  };

  return ICU;
}();

ICU.type = 'i18nFormat';
export default ICU;