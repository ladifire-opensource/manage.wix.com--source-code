"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var urlMap_1 = require("./urlMap");
var experiments_cache_1 = require("./experiments-cache");
var experiments_data_utils_1 = require("./experiments-data-utils");
var http_request_1 = require("./http-request");
var global_defaults_1 = require("./conduction-utils/global-defaults");
var request_context_1 = require("./conduction-utils/request-context");
var base_url_1 = require("./base-url");
var global_defaults_checks_1 = require("./conduction-utils/global-defaults-checks");
var Experiments = /** @class */ (function () {
    function Experiments(obj) {
        if (obj === void 0) { obj = {}; }
        var globalDefaults = global_defaults_1.getGlobalDefaults();
        this.useNewApi =
            typeof obj.useNewApi !== 'undefined'
                ? obj.useNewApi
                : globalDefaults.useNewApi || false;
        this.experiments = obj.experiments || {};
        this.loaders = new Map();
        this.baseUrl = base_url_1.baseUrl(this.useNewApi, obj.baseUrl);
        this.requestContext = obj.requestContext || global_defaults_checks_1.getGlobalRequestContext(globalDefaults);
        if (obj.scope) {
            this.load(obj.scope);
        }
    }
    Experiments.prototype.add = function (obj) {
        this.experiments = tslib_1.__assign(tslib_1.__assign({}, this.experiments), obj);
    };
    Experiments.prototype.get = function (key) {
        return this.experiments[key];
    };
    Experiments.prototype.enabled = function (key) {
        return this.get(key) === 'true';
    };
    Experiments.prototype.all = function () {
        return this.experiments;
    };
    Experiments.prototype._addLoader = function (url, promise) {
        var _this = this;
        this.loaders.set(url, promise);
        promise.then(function () {
            _this.loaders.delete(url);
        });
        return promise;
    };
    Experiments.prototype._getUrlWithFallback = function (url, fallback) {
        var cachedResponse = experiments_cache_1.getCacheInstance().getUrlResponse(url);
        if (cachedResponse !== undefined) {
            return Promise.resolve(cachedResponse);
        }
        var existingRequest = this.loaders.get(url);
        if (existingRequest !== undefined) {
            return existingRequest;
        }
        return http_request_1.httpRequest(url)
            .then(function (response) {
            experiments_cache_1.getCacheInstance().addUrlResponse(url, response);
            return response;
        })
            .catch(function () { return fallback; });
    };
    Experiments.prototype.load = function (scope) {
        var _this = this;
        var scopeConductionPath = urlMap_1.getAllInScopePath(scope, this.useNewApi);
        var requestContextQuery = this.useNewApi ? request_context_1.getRequestContextQuery(this.requestContext) : '';
        var url = "" + this.baseUrl + scopeConductionPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, {})
            .then(experiments_data_utils_1.tryParse)
            .then(function (response) { return _this.useNewApi ? response.values : response; })
            .then(function (obj) { return _this.add(obj); });
        return this._addLoader(url, result);
    };
    Experiments.prototype.conduct = function (spec, fallbackValue) {
        var _a;
        var _this = this;
        // check if a spec value was already loaded to the cache indirectly through another request
        var cachedResponse = experiments_cache_1.getCacheInstance().getExperimentValue(spec, this.useNewApi);
        if (cachedResponse !== undefined) {
            this.add((_a = {}, _a[spec] = cachedResponse, _a));
            return Promise.resolve(cachedResponse);
        }
        var experimentsPath = urlMap_1.getExperimentPath(spec, fallbackValue, this.useNewApi);
        var requestContextQuery = this.useNewApi ? request_context_1.getRequestContextQuery(this.requestContext) : '';
        var url = "" + this.baseUrl + experimentsPath + requestContextQuery;
        var result = this._getUrlWithFallback(url, fallbackValue).then(function (response) {
            var _a;
            var value = _this.useNewApi ? JSON.parse(response).value : response;
            _this.add((_a = {}, _a[spec] = value, _a));
            return value;
        });
        return this._addLoader(url, result);
    };
    Experiments.prototype.pending = function () {
        return !!this.loaders.size;
    };
    Experiments.prototype.ready = function () {
        return Promise.all(Array.from(this.loaders.values()));
    };
    return Experiments;
}());
exports.default = Experiments;
//# sourceMappingURL=index.js.map