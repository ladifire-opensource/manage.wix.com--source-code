"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var deferred_1 = __importDefault(require("./deferred"));
var ResponseError = /** @class */ (function (_super) {
    __extends(ResponseError, _super);
    function ResponseError(reason, response) {
        var _this = _super.call(this, reason) || this;
        _this.reason = reason;
        _this.response = response;
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, ResponseError.prototype);
        return _this;
    }
    ResponseError.prototype.getStatus = function () {
        return (this.response && this.response.status) || -1;
    };
    return ResponseError;
}(Error));
exports.ResponseError = ResponseError;
function isCancel(error) {
    return error.reason === 'canceled';
}
exports.isCancel = isCancel;
function post(url, payload, config) {
    if (config === void 0) { config = {}; }
    var deferred = new deferred_1.default();
    var headers = config.headers || {};
    var request = new XMLHttpRequest();
    request.open('POST', url, true);
    request.onreadystatechange = function () {
        if (request.readyState !== 4) {
            return;
        }
        // request errored out, will be handled by onerror handler
        if (request.status === 0) {
            return;
        }
        var response = {
            data: maybeJSON(request.responseText),
            status: request.status,
        };
        settle(deferred, request, response);
    };
    request.onerror = function () { return deferred.reject(new ResponseError('network error')); };
    if (payload !== undefined) {
        request.setRequestHeader('Content-Type', 'application/json;charset=utf-8');
    }
    if (config.onChunk !== undefined) {
        var prevIndex_1 = 0;
        request.onprogress = function () {
            if (request.status !== 200) {
                return;
            }
            var currIndex = request.responseText.length;
            if (prevIndex_1 === currIndex) {
                return;
            }
            request.responseText
                .substring(prevIndex_1, currIndex)
                .split('\n')
                .filter(function (x) { return x; })
                .forEach(function (chunk) { return config.onChunk(maybeJSON(chunk)); });
            prevIndex_1 = currIndex;
        };
    }
    var xsrf = readCookie('XSRF-TOKEN');
    if (xsrf !== undefined) {
        headers['X-XSRF-TOKEN'] = xsrf;
    }
    Object.keys(headers).forEach(function (key) {
        var value = headers[key];
        request.setRequestHeader(key, value);
    });
    if (config.cancelToken !== undefined) {
        config.cancelToken.promise.then(function () {
            request.abort();
            deferred.reject(new ResponseError('canceled'));
        });
    }
    if (payload === undefined) {
        payload = null; // IE tends to send "undefined" as string
    }
    else {
        payload = JSON.stringify(payload);
    }
    request.send(payload);
    return deferred.promise;
}
exports.post = post;
function readCookie(name) {
    var match = typeof window !== 'undefined' &&
        window.document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : undefined;
}
function settle(deferred, request, response) {
    if (verifyStatus(request)) {
        deferred.resolve(response);
    }
    else {
        deferred.reject(new ResponseError('server error', response));
    }
}
function verifyStatus(request) {
    var status = request.status;
    return status >= 200 && status < 300;
}
function maybeJSON(data) {
    try {
        return JSON.parse(data);
    }
    catch (_a) {
        return data;
    }
}
//# sourceMappingURL=request.js.map