import { __awaiter, __generator } from "tslib";
import Message from '../domain/message';
import ChatroomApi from './api.chatroom';
import chatroomsActionsFactory from '../state/action/action.chatrooms';
import messagesActionsFactory from '../state/action/action.messages';
import ServerApi from '../server-api/server-api';
import CurrentUser from '../server-api/current-user';
import appService from '../services/app-service';
import * as Constants from '../constants/constants';
import TextTypingService from '../services/text-typing.service';
import PersistenceService from '../services/persistence.service';
import SubscriptionService from '../services/subscription-service';
import ChatAgent from '../server-api/chat-agent';
import { setupStore } from '../state';
import { getCachedChatToken, getHandshakeChatToken, isExpiredToken, saveToken, } from '../services/handshake-token-service';
import ChatroomsApi from './api.chatrooms';
import MessagesApi from './api.messages';
import { isExperimentOn } from '../utils/experiments-utils';
import FirebaseService from 'firebase-service';
import { onRealtimeEvent } from '../realtime/event-handlers';
import StateToDbService from '../state/db/state-to-db.service';
import { UnseenChatroomCountApi } from '../modules/unseen-chatroom-count/api.unseen-chatroom-count';
import UnseenChatroomCountActions from '../modules/unseen-chatroom-count/action.unseen-chatroom-count';
import UnreadChatroomCountActions from '../modules/unread-chatroom-count/action.unread-chatroom-count';
import PresencePublicApi from './public/public-api.presence';
import presenceActions from '../presence/action.presence';
import { realtimeClientFactory } from '../realtime/client';
import { DEFAULT_THROTTLE_THRESHOLD } from '../constants/constants';
import ConnectivityService from '../services/connectivity.service';
import { Repository } from '../server-api/repository';
import MasterPageManager from '../services/master-page-manager';
import UnreadChatroomCountApi from '../modules/unread-chatroom-count/api.unread-chatroom-count';
/**
 * Chat SDK
 * @doc chat-sdk
 * singleton object that holds all public API calls
 */
var SDK = /** @class */ (function () {
    function SDK() {
        var _this = this;
        this.unseenChatroom = {
            /**
             * Tells the SDK that you want to know how many rooms have unread messages in them,
             * with the option to "mark as seen".
             * The callback will give you a number every time the number of unread rooms changes, unless the count is above
             * some threshold, at which point it'll give you the threshold number and a `hasOverflow: true`.
             * @param callback
             * @param filter
             */
            subscribeToCount: function (callback, filter) {
                _this._assertInitialized();
                return _this.unseenChatroomCountApi.subscribe(callback, filter);
            },
            /**
             * Marks a given chatrooms filter as seen
             * @param filter
             */
            markChatroomsAsSeen: function (filter) {
                _this._assertInitialized();
                return _this.unseenChatroomCountApi.markChatroomsAsSeen(filter);
            },
        };
        this._initialized = false;
        this._experiments = {};
        this._onConnectCallbacks = [];
        this._onConnectingCallbacks = [];
        this._onConnectionEstablishedCallbacks = [];
        this._onDisconnectCallbacks = [];
        this._onInitCallbacks = [];
        this._connected = false;
        this._connectivityProviderWasSet = false;
        this._currentUser = new CurrentUser();
    }
    /**
     * If the sdk is already initialized it will resolve immediately. Otherwise it will wait until initialization is
     * complete and then resolve. This is useful if you are getting errors that some operation is not allowed
     * until the sdk is initialized.
     */
    SDK.prototype.waitForInitialized = function () {
        var _this = this;
        var resolveOnInit = function (resolve) { return _this._registerOnInit(function () { return resolve(); }); };
        return new Promise(function (resolve) { return resolveOnInit(resolve); });
    };
    Object.defineProperty(SDK.prototype, "initialized", {
        /**
         * Will be `true` only after the initialization process is completed. If you need to wait for initialization
         * to complete before continuing, see `waitForInitialized`
         */
        get: function () {
            return this._initialized;
        },
        enumerable: false,
        configurable: true
    });
    SDK.prototype.initWithHandshake = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenServer, chatToken, sdk;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _verifyInitParams(params);
                        this.setConnectivityProviderIfNeeded(params.connectivityProvider);
                        this.clear();
                        tokenServer = params.tokenServer;
                        if (!tokenServer) {
                            throw new Error('Trying to call init with handshake without passing the issue server url');
                        }
                        return [4 /*yield*/, getCachedChatToken(params.persistenceEngine)];
                    case 1:
                        chatToken = _a.sent();
                        if (!(!chatToken && tokenServer && ConnectivityService.online)) return [3 /*break*/, 3];
                        return [4 /*yield*/, getHandshakeChatToken(tokenServer)];
                    case 2:
                        chatToken = _a.sent();
                        _a.label = 3;
                    case 3:
                        sdk = chatSdk.init(Object.assign({}, params, { chatToken: chatToken }));
                        if (!chatToken) return [3 /*break*/, 5];
                        return [4 /*yield*/, saveToken(chatToken, params.persistenceEngine)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, sdk];
                }
            });
        });
    };
    SDK.prototype.setConnectivityProviderIfNeeded = function (connectivityProvider) {
        if (connectivityProvider && !this._connectivityProviderWasSet) {
            ConnectivityService.setConnectivityProvider(connectivityProvider);
            this._connectivityProviderWasSet = true;
        }
    };
    /**
     * @function init
     * Initialize the SDK
     * @param initChatSdkParams
     * @return initiliazed sdk
     */
    SDK.prototype.init = function (initChatSdkParams) {
        var _this = this;
        var chatToken = initChatSdkParams.chatToken, _a = initChatSdkParams.preFetch, preFetch = _a === void 0 ? false : _a;
        this.initServices(initChatSdkParams);
        this._initialized = true;
        this.notifyOnInit();
        var wasOnlineOnInit = ConnectivityService.online;
        ConnectivityService.waitForOnline.then(function () {
            if (preFetch) {
                _this._fetchRooms({ isSilent: false });
            }
            _this.connectToRealtime({ chatToken: chatToken, eventHooks: _this._eventHooks }).catch(function (e) {
                console.error('ErrorOnConnectToRealtime', e);
            });
            _this.serverApi.http$fetchCurrentUserDisplayData().then(function (displayData) {
                _this._currentUser.displayData = displayData;
            });
            _this._connected = true;
            _this._onConnectCallbacks.forEach(function (cb) { return cb(); });
            _this.chatroomsApi.fetchMessageDrafts();
            if (!wasOnlineOnInit) {
                _this.subscriptionService.refreshSubscribedData();
            }
            ConnectivityService.executeEveryTimeOnBackToOnline(_this.reconnect.bind(_this, { chatToken: chatToken, tokenServer: initChatSdkParams.tokenServer }));
            ConnectivityService.executeEveryTimeOnOffline(_this.disconnect.bind(_this));
        });
        return this;
    };
    SDK.prototype.initServices = function (initChatSdkParams) {
        var chatServerUrl = initChatSdkParams.chatServerUrl, chatToken = initChatSdkParams.chatToken, _a = initChatSdkParams.eventHooks, eventHooks = _a === void 0 ? {} : _a, _b = initChatSdkParams.experiments, experiments = _b === void 0 ? {} : _b, appName = initChatSdkParams.appName, persistenceEngine = initChatSdkParams.persistenceEngine, dbStorageEngine = initChatSdkParams.dbStorageEngine, httpHeaders = initChatSdkParams.httpHeaders, tokenServer = initChatSdkParams.tokenServer, throttleThreshold = initChatSdkParams.throttleThreshold, connectivityProvider = initChatSdkParams.connectivityProvider, presenceOptions = initChatSdkParams.presenceOptions;
        _verifyInitParams({ chatServerUrl: chatServerUrl, chatToken: chatToken, tokenServer: tokenServer });
        this.clear();
        this._currentUser.loadJwtChatToken(chatToken);
        appService.setAppName(appName);
        this._currentUser.token = chatToken;
        this._experiments = experiments;
        this._eventHooks = Object.assign(defaultEventHooks, eventHooks);
        this.realtimeClient = realtimeClientFactory(new FirebaseService(undefined, {
            atomicServerTime: this.isExperimentOn(Constants.experiments.FirebaseAtomicServerTime),
        }));
        var subscriptionService = new SubscriptionService();
        var _throttleThreshold = throttleThreshold !== undefined ? throttleThreshold : DEFAULT_THROTTLE_THRESHOLD;
        var chatAgent;
        if (tokenServer) {
            chatAgent = new ChatAgent({
                baseUrl: chatServerUrl,
                currentUser: this._currentUser,
                httpHeaders: httpHeaders,
                tokenServer: tokenServer,
                throttleThreshold: _throttleThreshold,
            });
        }
        else {
            chatAgent = new ChatAgent({
                baseUrl: chatServerUrl,
                currentUser: this._currentUser,
                httpHeaders: httpHeaders,
                throttleThreshold: _throttleThreshold,
            });
        }
        this.serverApi = new ServerApi(chatAgent);
        this.repository = new Repository(chatAgent);
        MasterPageManager.setServerApi(this.repository);
        this.setConnectivityProviderIfNeeded(connectivityProvider);
        this.persistenceService = new PersistenceService(persistenceEngine, this.getUserId(), this._currentUser.participantIds);
        var shouldUseDBStorage = this.isExperimentOn(Constants.experiments.DBStorage);
        this.dbStorageService = shouldUseDBStorage && dbStorageEngine ? new StateToDbService(dbStorageEngine) : undefined;
        var shouldUseRepository = this.isExperimentOn(Constants.experiments.UseRepository);
        this.unseenChatroomCountActions = new UnseenChatroomCountActions(this.serverApi);
        this.unreadChatroomCountActions = new UnreadChatroomCountActions(this.serverApi);
        var unreadChatroomCountActions = this.unreadChatroomCountActions;
        var chatroomsActions = chatroomsActionsFactory(shouldUseRepository ? this.repository : this.serverApi, this.persistenceService, this._eventHooks, this.unseenChatroomCountActions, unreadChatroomCountActions, experiments, this.dbStorageService);
        this.store = this._setupStoreReuseIfNecessary(chatroomsActions);
        this.unseenChatroomCountApi = new UnseenChatroomCountApi({
            store: this.store,
            actions: this.unseenChatroomCountActions,
        });
        this.unreadChatroomCountApi = new UnreadChatroomCountApi({
            store: this.store,
            actions: this.unreadChatroomCountActions,
        });
        var chatroomsApi = new ChatroomsApi({
            store: this.store,
            chatroomsActions: chatroomsActions,
            subscriptionService: subscriptionService,
            serverApi: this.serverApi,
            unreadChatroomCountActions: this.unreadChatroomCountActions,
        });
        var chatroomApi = new ChatroomApi({
            store: this.store,
            chatroomsActions: chatroomsActions,
            subscriptionService: subscriptionService,
            currentUser: this._currentUser,
            enrichedChatroom: this.isExperimentOn(Constants.experiments.EnrichedChatroom),
        });
        this.messagesActions = messagesActionsFactory(this.serverApi);
        var messagesApi = new MessagesApi({
            store: this.store,
            messagesActions: this.messagesActions,
            subscriptionService: subscriptionService,
            drillInMessageIndications: this.isExperimentOn(Constants.experiments.DrillInMessageIndications),
        });
        var textTypingService = new TextTypingService(this.store, chatroomsActions, this.serverApi, this.persistenceService);
        this.presenceOptions = presenceOptions;
        this.presence = new PresencePublicApi(this._currentUser, this.serverApi, this.store);
        Object.assign(this, {
            subscriptionService: subscriptionService,
            chatroomsActions: chatroomsActions,
            chatroomsApi: chatroomsApi,
            chatroomApi: chatroomApi,
            messagesApi: messagesApi,
            textTypingService: textTypingService,
        });
    };
    /**
     * Un-initializes the sdk and disconnects associated realtime sockets. After this call,
     * the sdk is essentially dead until you call init again. Useful if the user logged out or
     * completely switched contexts to the point where a new token will need to be issued and
     * everything started from scratch.
     *
     * If you want to keep the data you have but shutoff the realtime websocket to not abuse the network,
     * use `disconnect` instead.
     */
    SDK.prototype.clear = function () {
        if (this._initialized) {
            this.store.dispatch(this.chatroomsActions.action$resetStore());
            this._initialized = false;
        }
        if (this._connected) {
            this.disconnect();
        }
    };
    /**
     * Disconnects the sdk from receiving realtime events. Useful if you need to be conservative with
     * network traffic, like in a mobile app, because it will close the websocket. If you do this, your data
     * will be stale and you will need to call `reconnect` to get back in sync.
     */
    SDK.prototype.disconnect = function () {
        MasterPageManager.clearAllMasterPages();
        this.store.dispatch(presenceActions.action$clearPresence());
        this._onDisconnectCallbacks.forEach(function (cb) { return cb(); });
        this.realtimeClient.disconnect();
        this._connected = false;
    };
    //TODO remove chat-agent._issueNewTokenIfNeeded should be removed and use this
    SDK.prototype.reissueTokenIfNeeded = function (_a) {
        var chatToken = _a.chatToken, tokenServer = _a.tokenServer;
        return __awaiter(this, void 0, void 0, function () {
            var _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!tokenServer) {
                            return [2 /*return*/, Promise.reject('TokenServer must be provided')];
                        }
                        if (!(chatToken && !isExpiredToken(chatToken))) return [3 /*break*/, 1];
                        this._currentUser.token = chatToken;
                        return [3 /*break*/, 3];
                    case 1:
                        if (!ConnectivityService.online) {
                            return [2 /*return*/, Promise.reject('Unable to reissue token when offline')];
                        }
                        _b = this._currentUser;
                        return [4 /*yield*/, getHandshakeChatToken(tokenServer)];
                    case 2:
                        _b.token = _c.sent();
                        _c.label = 3;
                    case 3:
                        this._currentUser.loadJwtChatToken(chatToken);
                        return [2 /*return*/, this._currentUser.token];
                }
            });
        });
    };
    /**
     * See `disconnect()` - if you disconnected, you have to reconnect. In addition
     * to resuming listening to realtime events, sdk will refresh any data that may be
     * stale if there is an active subscription listening to that data
     * At least one of the following must be provided:
     * @param reconnectParams ReconnectSdkParams
     */
    SDK.prototype.reconnect = function (reconnectParams) {
        return __awaiter(this, void 0, void 0, function () {
            var chatToken;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._assertInitialized();
                        if (this._connected) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, this.reissueTokenIfNeeded(reconnectParams)];
                    case 1:
                        chatToken = _a.sent();
                        this._onConnectCallbacks.forEach(function (cb) { return cb(); });
                        return [2 /*return*/, Promise.all([
                                this.subscriptionService.refreshSubscribedData(),
                                this.connectToRealtime({ chatToken: chatToken, eventHooks: this._eventHooks }),
                            ])];
                }
            });
        });
    };
    SDK.prototype.reconnectWithHandshake = function (_a) {
        var tokenServer = _a.tokenServer;
        return __awaiter(this, void 0, void 0, function () {
            var chatToken;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!tokenServer) {
                            throw new Error('Trying to reconnect chat-sdk without a `tokenServer`');
                        }
                        if (this._connected) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, getCachedChatToken(this.persistenceService.persistenceEngine)];
                    case 1:
                        chatToken = _b.sent();
                        return [2 /*return*/, this.reconnect({ chatToken: chatToken, tokenServer: tokenServer })];
                }
            });
        });
    };
    /**
     * Register a callback that will be called every time sdk starts opening a connection to our realtime server.
     * Essentially once during initialization and again each time `reconnect` is called.
     * @param callback
     */
    SDK.prototype.onConnecting = function (callback) {
        this._onConnectingCallbacks.push(callback);
    };
    /**
     * Register a callback that will be called every time sdk finishes opening a connection to our realtime server.
     * Essentially once during initialization and again each time `reconnect` is called.
     * @param callback
     */
    SDK.prototype.onConnectionEstablished = function (callback) {
        this._onConnectionEstablishedCallbacks.push(callback);
    };
    /**
     * Register a callback that will be called whenever `disconnect()` is called. This is not intended as a way
     * to monitor whenever a connection is interrupted for reasons other than the consumer calling `disconnect`.
     * @param callback
     */
    SDK.prototype.onDisconnect = function (callback) {
        this._onDisconnectCallbacks.push(callback);
    };
    /**
     * @description You use this subscription when you are
     interested in finding out which chatrooms are relevant
     to the current `chatToken`'s authentication and the provided set of `filter`s.
     The data that comes back in the callback is meant to be enough to render a chatroom list,
     and is order by lastMessage timestamp descending.
  
     Currently, you can filter chatrooms by `participantId`, `isArchived` and `isUnread`. When you subscribe to a filtered list,
     the callback will only be called when a chatroom inside the specified filter changes. You can
     subscribe to multiple filters simultaneously, each one is independent.
     * @param {Function} callback
     * @param filter
     */
    SDK.prototype.subscribeToChatRoomsList = function (_a) {
        var subscriberId = _a.subscriberId, callback = _a.callback, filter = _a.filter;
        this._assertInitialized();
        return this.chatroomsApi.subscribeToChatRoomsList({ subscriberId: subscriberId, callback: callback, filter: filter });
    };
    /**
     * @function subscribeToChatRoom
     * get notified when the room is changed.
     * @param {ChatroomId} chatroomId
     * @param {Function} onChange - called with `room` on any change in the room.
     * @param {Function} onNewMessage - called when a new message is added to a *NON EMPTY* room (i.e. will not be called for the first message added)
     * @param {Function} onInitialFetchDone - called when the initial fetch of room data is completed
     * @param {Function} onError - called with `error` string when an error occurs (for example network error)
     * @param onNewRealtimeMessage - Deprecated, do not use
     * @returns {Function} unsubscribe function
     */
    SDK.prototype.subscribeToChatRoom = function (_a) {
        var chatroomId = _a.chatroomId, onChange = _a.onChange, onNewMessage = _a.onNewMessage, onInitialFetchDone = _a.onInitialFetchDone, onError = _a.onError;
        this._assertInitialized();
        return this.chatroomApi.subscribeToChatRoom({ chatroomId: chatroomId, onChange: onChange, onNewMessage: onNewMessage, onInitialFetchDone: onInitialFetchDone, onError: onError });
    };
    /**
     * Tells the SDK that you want to know how many rooms have unread messages in them.
     The callback will give you a number every time the number of unread rooms changes, unless the count is above
     some threshold, at which point it'll give you the threshold number and a `hasOverflow: true`.
     * @param {GlobalUnreadsCountCallbackFunc} callback
     * @param {UnreadChatroomCountFilter} filter - Filter used when fetching initial unread count
     */
    SDK.prototype.subscribeToGlobalUnreadStatus = function (_a) {
        var callback = _a.callback, filter = _a.filter;
        this._assertInitialized();
        if (!filter) {
            throw Error('Filter is now required');
        }
        return this.unreadChatroomCountApi.subscribe(callback, filter);
    };
    /**
     * Tells the SDK that you want to know how many rooms have unread messages in them, broken down by participant.
     The callback will give you a number every time the number of unread rooms changes, unless the count is above
     some threshold (UNREAD_CHATROOM_IDS_COUNT_LIMIT_PER_PARTICIPANT), at which point it'll give you the threshold number, currently - 100.
     * @param {GlobalUnreadsBreakdownCountCallbackFunc} callback
     * @param {UnreadChatroomCountFilter} filter - Filter used when fetching initial unread count
     */
    SDK.prototype.subscribeToBreakdownUnreadStatus = function (_a) {
        var callback = _a.callback, filter = _a.filter;
        this._assertInitialized();
        return this.unreadChatroomCountApi.subscribeToBreakdown(callback, filter);
    };
    /**
     *
     * Returns the current snapshot of unread count and a list of unread chat rooms ids.
     * if the unread count is bigger than the "unreadChatroomLimit" param, it will not return the chatrooms ids.
     *
     * @param filter - in case an empty array is passed then the unread is for all sites. Otherwise it's the unread count
     * for the specific participants ids that are passed
     * @param unreadChatroomLimit - optional (default is set to ServerApi.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT (100))
     */
    SDK.prototype.getUnreadCount = function (filter, unreadChatroomLimit) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._assertInitialized();
                return [2 /*return*/, this.serverApi.http$fetchUnreadChatroomIds({ filter: filter, unreadChatroomLimit: unreadChatroomLimit })];
            });
        });
    };
    /**
     * @function subscribeToDrillInMessageIndications
     * Tells the SDK that you want to monitor seen/sent indications changes of a single message.
     the callback will be called only when a new indication added to the relevant message.
     For example: when a contact reads the message via email, the callback will be called with all seen/sent indications relevant to that message.
     Important thing to notice: message indication is different and does not include message status.
     to read more about message status click [here](docs/chat-platform/message-data-model.md#messageStatus).
     * @param {ChatroomId} chatroomId
     * @param {string} messageId
     * @param {number} sequence
     * @param {Function} callback - called with `messages indications` on any change in them.
     * @returns {Function} unsubscribe function
     */
    SDK.prototype.subscribeToDrillInMessageIndications = function (_a) {
        var chatroomId = _a.chatroomId, messageId = _a.messageId, sequence = _a.sequence, callback = _a.callback;
        this._assertInitialized();
        if (this.isExperimentOn(Constants.experiments.DrillInMessageIndications)) {
            return this.messagesApi.subscribeToDrillInMessageIndications({ chatroomId: chatroomId, messageId: messageId, sequence: sequence, callback: callback });
        }
    };
    SDK.prototype.getChatroom = function (_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.getChatroom({ chatroomId: chatroomId });
    };
    SDK.prototype.getUnreadCountForRoom = function (chatroomId) {
        return this.chatroomsApi.getUnreadCountForRoom(chatroomId);
    };
    SDK.prototype.getUnreadCountForRooms = function (chatroomIds) {
        return this.chatroomsApi.getUnreadCountForRooms(chatroomIds);
    };
    SDK.prototype.fetchRooms = function (_a) {
        var filter = _a.filter, cursor = _a.cursor, _b = _a.isSilent, isSilent = _b === void 0 ? false : _b;
        this._assertInitialized();
        return this._fetchRooms({ filter: filter, cursor: cursor, isSilent: isSilent });
    };
    SDK.prototype.sendMessage = function (message) {
        this._assertInitialized();
        return this.chatroomApi.sendMessage(message);
    };
    /**
     * Adds a message to the chatroom but DOES NOT send it to the server. To send, use `sendMessage`.
     * You do not have to add a message before sending it, but you can choose to do so. Typical use-case:
     * the user selected an image to send, so you want to add it to the chatroom so that it will be rendered
     * in the UI as the last message. But you need to finish uploading it somewhere before you can actually send
     * the message. So you call `addMessage` and then `sendMessage` once the upload is done.
     * @param dto
     * @param transit
     */
    SDK.prototype.addMessage = function (_a) {
        var dto = _a.dto, transit = _a.transit;
        this._assertInitialized();
        return this.chatroomApi.addMessage({ dto: dto, transit: transit });
    };
    SDK.prototype.addChatrooms = function (_a) {
        var rooms = _a.rooms;
        this._assertInitialized();
        return this.chatroomsApi.addRooms({ rooms: rooms });
    };
    /**
     * persist=false DOES NOT delete messages from the server's database, which is not supported by chat. This delete's only the
     * local, client-side copy of a message. Common use-case: a message failed to send (network error) so only exists
     * client-side. The user can choose to delete the message and try again.x
     * @param messageId
     */
    SDK.prototype.deleteMessage = function (messageId, persist) {
        if (persist === void 0) { persist = false; }
        this._assertInitialized();
        return this.chatroomApi.deleteMessage(messageId, persist);
    };
    SDK.prototype.resendMessage = function (messageId) {
        this._assertInitialized();
        return this.chatroomApi.resendMessage(messageId);
    };
    SDK.prototype.deleteLabel = function (params) {
        this._assertInitialized();
        return this.chatroomApi.deleteLabel(params);
    };
    SDK.prototype.unstarRoom = function (chatroomId) {
        this._assertInitialized();
        return this.chatroomApi.unstarRoom(chatroomId);
    };
    SDK.prototype.starRoom = function (chatroomId) {
        this._assertInitialized();
        return this.chatroomApi.starRoom(chatroomId);
    };
    SDK.prototype.notifyTyping = function (chatroomId, text) {
        this._assertInitialized();
        return this.textTypingService.notifyTyping(chatroomId, text);
    };
    SDK.prototype.notifyTypingTextChange = function (chatroomId, text, isActive) {
        if (isActive === void 0) { isActive = true; }
        this._assertInitialized();
        return this.textTypingService.notifyTextChange(chatroomId, text, isActive);
    };
    SDK.prototype.deleteChatroom = function (chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.deleteChatroom(chatroomId);
    };
    /**
     * @function deleteChatrooms
     * Bulk delete all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.deleteChatrooms = function (chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.deleteChatrooms(chatroomIds);
    };
    SDK.prototype.archiveChatroom = function (chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.archiveChatroom(chatroomId);
    };
    /**
     * @function archiveChatrooms
     * Bulk archive all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.archiveChatrooms = function (chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.archiveChatrooms(chatroomIds);
    };
    /**
     * @function unarchiveChatrooms
     * Bulk unarchive all chatrooms provided.
     * @param chatroomIds an array of chatroomIds
     */
    SDK.prototype.unarchiveChatrooms = function (chatroomIds) {
        this._assertInitialized();
        return this.chatroomsApi.unarchiveChatrooms(chatroomIds);
    };
    SDK.prototype.unarchiveChatroom = function (chatroomId) {
        this._assertInitialized();
        return this.chatroomsApi.unarchiveChatroom(chatroomId);
    };
    SDK.prototype.setLastMessageUnread = function (_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.setLastMessageUnread({ chatroomId: chatroomId });
    };
    SDK.prototype.isExperimentOn = function (experiment) {
        return isExperimentOn(this._experiments, experiment);
    };
    SDK.prototype.getUserId = function () {
        return this._currentUser.userId;
    };
    SDK.prototype.clearPersistence = function () {
        if (this.persistenceService) {
            this.persistenceService.clearMessageDrafts();
            this.persistenceService.clearToken();
        }
        this.dbStorageService && this.dbStorageService.clearAll();
    };
    /**
     * @function setAllRoomsAsRead
     *
     * Set all chat rooms for a given filter to be read.
     * If a filter is not provided all rooms will be set to read.
     * @param {ChatroomsListFilter} filter of chatrooms
     */
    SDK.prototype.setAllRoomsAsRead = function (filter, updateServer) {
        if (updateServer === void 0) { updateServer = true; }
        return this.chatroomsApi.markAllRoomsAsRead(filter, updateServer);
    };
    /**
     * @function setMessagesRead
     *
     * Set messages as read for a specific room.
     * Note that latest (known) message sequence will be set for the room (meaning that on a rare race condition,
     * if another message is received around the time this call is made, room can go back to an unread state).
     * @param {chatroomId}
     */
    SDK.prototype.setMessagesRead = function (_a) {
        var chatroomId = _a.chatroomId;
        this._assertInitialized();
        return this.chatroomApi.setMessagesRead({ chatroomId: chatroomId });
    };
    /**
     * @function setRoomsMessagesRead
     *
     * Set messages as read for a provided rooms ids.
     * Note that latest (known) message sequence will be set for each room (meaning that on a rare race condition,
     * if another message is received around the time this call is made, room can go back to an unread state).
     * @param {chatroomIds}
     */
    SDK.prototype.setRoomsMessagesRead = function (chatroomIds) {
        return this.chatroomApi.setRoomsMessagesRead(chatroomIds);
    };
    /**
     * @function: search
     *
     * @description search for a specific search term in all chatrooms name and messages.
     * Returns search results according to SearchResults type.
     * @param searchTerm: string
     * @param participantIds: string[] - relevant search results only for given participantIds
     */
    SDK.prototype.search = function (_a) {
        var searchTerm = _a.searchTerm, participantIds = _a.participantIds, _b = _a.chatroomsPageSize, chatroomsPageSize = _b === void 0 ? 10 : _b, _c = _a.chatroomsNextPointer, chatroomsNextPointer = _c === void 0 ? 0 : _c, _d = _a.messagesPageSize, messagesPageSize = _d === void 0 ? 10 : _d, _e = _a.messagesNextPointer, messagesNextPointer = _e === void 0 ? 0 : _e;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_f) {
                return [2 /*return*/, this.chatroomsApi.search({
                        searchTerm: searchTerm,
                        participantIds: participantIds,
                        chatroomsPageSize: chatroomsPageSize,
                        chatroomsNextPointer: chatroomsNextPointer,
                        messagesPageSize: messagesPageSize,
                        messagesNextPointer: messagesNextPointer,
                    })];
            });
        });
    };
    /**
     * @function: getMessagesPage
     *
     * @description get a specific messages page accrodind to given message sequence
     * @param chatroomId: string
     * @param messageSequence: number - the messageSequence that will be in the middle of the given page
     * @param pageSize: number
     */
    SDK.prototype.getMessagesPage = function (_a) {
        var chatroomId = _a.chatroomId, messageSequence = _a.messageSequence, pageSize = _a.pageSize;
        return __awaiter(this, void 0, void 0, function () {
            var messages;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.serverApi.http$fetchRoomMessagesPage({ chatroomId: chatroomId, messageSequence: messageSequence, pageSize: pageSize })];
                    case 1:
                        messages = _b.sent();
                        return [2 /*return*/, messages.reverse().map(function (message) { return new Message(message); })];
                }
            });
        });
    };
    /**
     * @function: buttonInteraction
     *
     * @description reacts to a button interaction (click)
     * @param button: Button - the clicked button, with it's metadata
     * @param chatroomId: string
     */
    SDK.prototype.buttonInteraction = function (button, chatroomId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._assertInitialized();
                        return [4 /*yield*/, this.chatroomApi.buttonInteraction(button, chatroomId)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @function: updateHttpHeaders
     *
     * @description Updates the headers that all the agent's http requests are sent with. This is useful in cases like authentication-related headers that expire and need refreshed.
     * @param headers: An object containing HTTP header key-value pairs. This will update existing headers, but won't get rid of any.
     *
     * You may need to call `reconnect()` after updating the headers.
     */
    SDK.prototype.updateHttpHeaders = function (headers) {
        this.serverApi.updateHttpHeaders(headers);
    };
    SDK.prototype.notifyOnInit = function () {
        this._onInitCallbacks.forEach(function (callback) { return callback(); });
    };
    SDK.prototype._registerOnInit = function (callback) {
        if (!this._initialized) {
            this._onInitCallbacks.push(callback);
        }
        else {
            callback();
        }
    };
    SDK.prototype.connectToRealtime = function (_a) {
        var _this = this;
        var _b, _c;
        var chatToken = _a.chatToken, eventHooks = _a.eventHooks;
        if (!((_b = this.presenceOptions) === null || _b === void 0 ? void 0 : _b.disableWatch)) {
            this.presence.watch((_c = this.presenceOptions) === null || _c === void 0 ? void 0 : _c.useNewConvention);
        }
        this.store.dispatch(presenceActions.action$clearStalePresenceSessions());
        this._onConnectingCallbacks.forEach(function (cb) { return cb(); });
        if (!chatToken) {
            return Promise.reject('Unexpected error: Unable to connect to realtime without a chatToken');
        }
        return this.serverApi
            .http$initRealtimeToken(chatToken)
            .then(function (realtimeServiceSetup) {
            return _this.realtimeClient.connect({
                realtimeServiceSetup: realtimeServiceSetup,
                onEvent: function (data) {
                    return onRealtimeEvent({
                        store: _this.store,
                        chatroomsActions: _this.chatroomsActions,
                        messagesActions: _this.messagesActions,
                        data: data,
                        currentUser: _this._currentUser,
                    });
                },
                eventHooks: eventHooks,
            });
        })
            .then(function () { return _this._onConnectionEstablishedCallbacks.forEach(function (cb) { return cb(); }); });
    };
    SDK.prototype._fetchRooms = function (_a) {
        var _b = _a.filter, filter = _b === void 0 ? undefined : _b, _c = _a.cursor, cursor = _c === void 0 ? undefined : _c, _d = _a.isSilent, isSilent = _d === void 0 ? false : _d;
        return this.chatroomsApi.fetchRooms({ filter: filter, cursor: cursor, isSilent: isSilent });
    };
    SDK.prototype._assertInitialized = function () {
        if (!this.initialized) {
            throw new Error('Trying to call chat-sdk without having it initialized');
        }
    };
    SDK.prototype._setupStoreReuseIfNecessary = function (chatroomsActions) {
        if (!this.existingStore) {
            if (this.dbStorageService) {
                this.existingStore = setupStore();
                this.dbStorageService.initStore(this.existingStore);
            }
            else {
                this.existingStore = setupStore();
            }
            return this.existingStore;
        }
        else {
            var store = this.existingStore;
            store.dispatch(chatroomsActions.action$resetStore());
            return store;
        }
    };
    return SDK;
}());
function _verifyInitParams(_a) {
    var chatServerUrl = _a.chatServerUrl, chatToken = _a.chatToken, tokenServer = _a.tokenServer;
    if (!chatToken && !tokenServer) {
        throw new Error('Trying to initialize chat-sdk without chatToken or tokenServer');
    }
    if (!chatServerUrl) {
        throw new Error('Trying to initialize chat-sdk without chatServerUrl');
    }
}
var defaultEventHooks = { reportMonitoringBi: function () { return null; } };
var getSdkFromWindowOrCreateNew = function () {
    if (typeof window === 'object') {
        if (!window.chatSdk) {
            window.chatSdk = new SDK();
        }
        return window.chatSdk;
    }
    return new SDK();
};
export var chatSdk = getSdkFromWindowOrCreateNew();
