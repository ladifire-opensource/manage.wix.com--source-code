import { __assign, __awaiter, __generator } from "tslib";
import _isEmpty from 'lodash/isEmpty';
import _maxBy from 'lodash/maxBy';
import _get from 'lodash/get';
import _difference from 'lodash/difference';
import * as messageDraftInitialStateCache from '../state/helpers/message-draft.initial-state-cache';
import * as chatEventEmitter from '../services/chat-event-emitter.service';
import Message from '../domain/message';
import { createGetChatroomMessagesSelector } from '../state/reducer/selector.messages';
import { getChatRoom } from '../state/stateReader';
import getRoomListener from './room-listener';
import { getMissingParticipantIds } from '../state/helpers/participants.helper';
import * as constants from '../constants/constants';
import { getLastMessageSequence } from '../state/reducer/selector.chatrooms';
import { buildEnrichedChatroomFromState } from '../domain/enriched-chat-room';
import { chatSdk } from '../api/chat-sdk';
import { Chatroom } from '../domain/chat-room';
import MessageOptions from '../domain/message-options';
import { calculateNextUnreadableSequence } from './message-sequence';
import { STAR_LABEL_ID } from '../constants/constants';
var ChatroomApi = /** @class */ (function () {
    function ChatroomApi(_a) {
        var store = _a.store, chatroomsActions = _a.chatroomsActions, subscriptionService = _a.subscriptionService, currentUser = _a.currentUser, enrichedChatroom = _a.enrichedChatroom;
        this.store = store;
        this.chatroomsActions = chatroomsActions;
        this.subscriptionService = subscriptionService;
        this.currentUser = currentUser;
        this.enrichedChatroom = enrichedChatroom;
    }
    ChatroomApi.prototype.subscribeToChatRoom = function (_a) {
        var _this = this;
        var chatroomId = _a.chatroomId, onChange = _a.onChange, onNewMessage = _a.onNewMessage, onInitialFetchDone = _a.onInitialFetchDone, onError = _a.onError;
        var _b = this, store = _b.store, chatroomsActions = _b.chatroomsActions;
        messageDraftInitialStateCache.invalidate(chatroomId);
        var _notifyChanges = getRoomListener(chatroomId);
        _notifyChanges({ store: store, onChange: onChange, onNewMessage: onNewMessage, onError: onError });
        var removeStoreSubscription = store.subscribe(function () { return _notifyChanges({ store: store, onChange: onChange, onNewMessage: onNewMessage, onError: onError }); });
        var getData = this._createDataFetcher(chatroomId, onInitialFetchDone);
        setTimeout(function () { return getData(); }, 0); // defer to next event loop so the subscriber could process existing data
        var removeFromSubscriptionService = this._registerSubscription(chatroomId, getData);
        var fetchMissingParticipantsDisplayData = function (enrichedChatroom) {
            var participantIdsFromIndicationsDto = enrichedChatroom.indications.lastMessageIndications.map(function (indication) { return indication.participantId; });
            var participantIdsFromParticipantsDto = enrichedChatroom.participants.items.map(function (participant) { return participant.id; });
            if (_isEmpty(_difference(participantIdsFromIndicationsDto, participantIdsFromParticipantsDto))) {
                return;
            }
            var missingParticipantIdsFromState = getMissingParticipantIds(participantIdsFromIndicationsDto);
            if (!_isEmpty(missingParticipantIdsFromState)) {
                store.dispatch(chatroomsActions.action$fetchRoomParticipantsDisplayData(chatroomId, missingParticipantIdsFromState));
            }
        };
        chatEventEmitter.addListener(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, fetchMissingParticipantsDisplayData);
        var fetchMessageErrorIndications = function () {
            _this.store.dispatch(_this.chatroomsActions.fetchMessageErrorIndications(chatroomId));
        };
        return {
            fetchMore: function (cursor) {
                store.dispatch(chatroomsActions.fetchRoomMessages(chatroomId, cursor)).then(function () {
                    fetchMessageErrorIndications();
                });
            },
            unsubscribe: function () {
                removeStoreSubscription();
                removeFromSubscriptionService();
                chatEventEmitter.removeListener(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, fetchMissingParticipantsDisplayData);
            },
        };
    };
    ChatroomApi.prototype._registerSubscription = function (chatroomId, getData) {
        var subscriptionIdentifier = { chatroomId: chatroomId };
        return this.subscriptionService.registerSubscription(subscriptionIdentifier, getData);
    };
    ChatroomApi.prototype._createDataFetcher = function (chatroomId, onInitialFetchDone) {
        var _this = this;
        // called on initial room fetch AND on refresh (via subscriptionService)
        return function () {
            return Promise.all([
                _this.store.dispatch(_this.chatroomsActions.action$fetchRoom(chatroomId, _this.enrichedChatroom)),
                _this.store.dispatch(_this.chatroomsActions.fetchRoomMessages(chatroomId)),
            ])
                .then(function () {
                _this.store.dispatch(_this.chatroomsActions.fetchMessageErrorIndications(chatroomId));
                if (onInitialFetchDone) {
                    var state = _this.store.getState();
                    var chatroom = buildEnrichedChatroomFromState(state, chatroomId);
                    onInitialFetchDone(chatroom);
                }
            })
                .catch(function (e) {
                console.error('CHAT4893 Error on room initial fetch', e);
            });
        };
    };
    ChatroomApi.prototype.getChatroom = function (_a) {
        var chatroomId = _a.chatroomId;
        return __awaiter(this, void 0, void 0, function () {
            var chatRoom;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        chatRoom = getChatRoom(this.store.getState(), chatroomId);
                        if (!_isEmpty(chatRoom)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.store.dispatch(this.chatroomsActions.action$fetchRoom(chatroomId, this.enrichedChatroom))];
                    case 1:
                        _b.sent();
                        chatRoom = getChatRoom(this.store.getState(), chatroomId);
                        _b.label = 2;
                    case 2: return [2 /*return*/, new Chatroom(chatRoom)];
                }
            });
        });
    };
    ChatroomApi.prototype.setMessagesRead = function (_a) {
        var chatroomId = _a.chatroomId;
        var lastReadMessageSequence = getLastMessageSequence(this.store.getState(), chatroomId);
        if (lastReadMessageSequence) {
            return this.store.dispatch(this.chatroomsActions.action$setMessagesRead(chatroomId, lastReadMessageSequence));
        }
    };
    ChatroomApi.prototype.setRoomsMessagesRead = function (chatroomIds) {
        var state = this.store.getState();
        var chatroomIdWithMostRecentMessageSequence = _maxBy(chatroomIds, function (chatroomId) {
            return _get(getChatRoom(state, chatroomId), 'lastMessage.sequence');
        });
        var mostRecentLastMessageSequence = chatroomIdWithMostRecentMessageSequence &&
            _get(getChatRoom(state, chatroomIdWithMostRecentMessageSequence), 'lastMessage.sequence');
        if (mostRecentLastMessageSequence) {
            this.store.dispatch(this.chatroomsActions.action$setRoomsMessagesRead(chatroomIds, mostRecentLastMessageSequence));
        }
    };
    ChatroomApi.prototype.setLastMessageUnread = function (_a) {
        var chatroomId = _a.chatroomId;
        var state = this.store.getState();
        var messages = createGetChatroomMessagesSelector(chatroomId)(state);
        var chatroom = getChatRoom(state, chatroomId);
        if (chatSdk.isExperimentOn(constants.experiments.UnreadableSequence)) {
            var unreadableSequence = calculateNextUnreadableSequence(chatroom.lastReadMessageSequence, messages, this.currentUser.userId);
            if (unreadableSequence) {
                return this.store.dispatch(this.chatroomsActions.action$setLastMessageUnread(chatroomId, unreadableSequence));
            }
        }
        else {
            var oneBeforeLastMessageSequence = messages.length > 0 && chatroom.lastReadMessageSequence ? chatroom.lastReadMessageSequence - 1 : 0;
            return this.store.dispatch(this.chatroomsActions.action$setLastMessageUnread(chatroomId, oneBeforeLastMessageSequence));
        }
    };
    ChatroomApi.prototype.sendMessage = function (message) {
        var _a = this, currentUser = _a.currentUser, store = _a.store, chatroomsActions = _a.chatroomsActions;
        var dto = message.dto;
        var dtoWithCurrentUserDetails = __assign(__assign({}, dto), { sender: dto.sender || { userId: currentUser.userId, type: currentUser.type }, senderDisplayData: currentUser.displayData });
        var messageToSend = new Message(dtoWithCurrentUserDetails);
        var sendMessageAction = chatroomsActions.action$sendMessage(messageToSend);
        return store.dispatch(sendMessageAction);
    };
    ChatroomApi.prototype.addMessage = function (_a) {
        var _b;
        var dto = _a.dto, transit = _a.transit;
        return __awaiter(this, void 0, void 0, function () {
            var _c, currentUser, store, chatroomsActions, messageIsFromCurrentUser, message, chatroomId, chatroomById, isEnrichedChatroom, fetchPromise;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _c = this, currentUser = _c.currentUser, store = _c.store, chatroomsActions = _c.chatroomsActions;
                        messageIsFromCurrentUser = !((_b = dto.sender) === null || _b === void 0 ? void 0 : _b.userId) || dto.sender.userId == currentUser.userId;
                        message = Object.assign(dto, { transit: transit }, messageIsFromCurrentUser
                            ? {
                                senderDisplayData: currentUser.displayData,
                                sender: { userId: currentUser.userId },
                            }
                            : {});
                        chatroomId = dto.chatroomId;
                        chatroomById = store.getState().chatrooms.byId[chatroomId];
                        if (!(!chatroomById || !chatroomById.id)) return [3 /*break*/, 2];
                        isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
                        fetchPromise = store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
                        if (!chatSdk.isExperimentOn(constants.experiments.UnseenChatroomCount)) return [3 /*break*/, 2];
                        return [4 /*yield*/, fetchPromise];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2: return [2 /*return*/, store.dispatch(chatroomsActions.action$addMessage(message, true, store.getState().chatrooms.byId[chatroomId]))];
                }
            });
        });
    };
    ChatroomApi.prototype.deleteMessage = function (messageId, persist) {
        if (persist === void 0) { persist = false; }
        var _a = this, store = _a.store, chatroomsActions = _a.chatroomsActions;
        var deleteMessageAction = chatroomsActions.action$deleteMessage(messageId, persist);
        return store.dispatch(deleteMessageAction);
    };
    ChatroomApi.prototype.resendMessage = function (messageId) {
        var _a = this, store = _a.store, chatroomsActions = _a.chatroomsActions;
        var resendMessageAction = chatroomsActions.action$resendMessage(messageId);
        return store.dispatch(resendMessageAction);
    };
    ChatroomApi.prototype.deleteLabel = function (_a) {
        var chatroomId = _a.chatroomId, labelId = _a.labelId;
        var _b = this, store = _b.store, chatroomsActions = _b.chatroomsActions;
        var deleteLabelAction = chatroomsActions.action$removeRoomLabels([{ chatroomId: chatroomId, labelId: labelId }], true);
        return store.dispatch(deleteLabelAction);
    };
    ChatroomApi.prototype.unstarRoom = function (chatroomId) {
        return this.deleteLabel({ chatroomId: chatroomId, labelId: STAR_LABEL_ID });
    };
    ChatroomApi.prototype.starRoom = function (chatroomId) {
        var _a = this, store = _a.store, chatroomsActions = _a.chatroomsActions;
        var updateLabelAction = chatroomsActions.action$updateRoomLabel({ chatroomId: chatroomId, labelId: STAR_LABEL_ID });
        return store.dispatch(updateLabelAction);
    };
    ChatroomApi.prototype.buttonInteraction = function (button, chatroomId) {
        var _a = this, store = _a.store, currentUser = _a.currentUser, chatroomsActions = _a.chatroomsActions;
        switch (button.type) {
            case 'POSTBACK': {
                if (button.payload) {
                    var message = Message.fromText({
                        text: button.text,
                        chatroomId: chatroomId,
                        userId: currentUser.userId,
                        userType: currentUser.type,
                        summary: button.text,
                        isEphemeral: true,
                        isSilent: true,
                    });
                    var messageOptions = new MessageOptions({
                        chatAction: __assign({ actionType: 'BUTTON_INTERACTION' }, button.payload),
                    });
                    return store.dispatch(chatroomsActions.action$sendPostbackMessage(message, messageOptions));
                }
                break;
            }
            default: {
                break;
            }
        }
    };
    return ChatroomApi;
}());
export default ChatroomApi;
