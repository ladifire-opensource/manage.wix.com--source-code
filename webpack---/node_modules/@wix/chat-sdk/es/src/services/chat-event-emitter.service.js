import { EventEmitter } from 'eventemitter3';
import EVENT_TYPES from '../realtime/event-types.constants';
var getEventEmitterFromWindowOrCreateNew = function () {
    if (typeof window === 'object') {
        if (!window._chatInternalEventEmitter) {
            window._chatInternalEventEmitter = new EventEmitter();
        }
        return window._chatInternalEventEmitter;
    }
    return new EventEmitter();
};
var eventEmitter = getEventEmitterFromWindowOrCreateNew();
var CHAT_EVENTS = {
    MESSAGES_READ: 'crm.events.messagesRead',
    MESSAGE_SENT: 'crm.events.messageSent',
    /**
     * Broadcast every time a new message arrives via realtime, for any chatroom
     * that the user has access to, NOT just those that are subscribed. Useful
     * for playing sounds or showing notifications.
     *
     * Important: This event is a best-effort event, meaning that if for whatever reason
     * the client is disconnected and doesn't receive the message in realtime, the event
     * will NOT be fired when the message eventually arrives and the data is synced.
     * This makes it less reliable than subscribing to a chatroom, which guarantees to
     * keep you up-to-date on all messages in a chatroom and fill in the gaps if connectivity is lost.
     * For this reason you should not use this to build a UI with a list of messages, instead subscribe to the room.
     * Use this for doing things that are only relevant if they are done immediately, like toasts and sounds.
     * @doc chat-event-emitter
     */
    NEW_REALTIME_MESSAGE: 'crm.events.newRealtimeMessage',
    BI: 'biEvent',
    BI_ERROR: 'biDebugErrorEvent',
    MONITORING_BI: 'monitoringBi',
    EXTERNAL_HOST: EVENT_TYPES.EXTERNAL_HOST,
    OFFLINE_CHANNEL_UPDATED: EVENT_TYPES.OFFLINE_CHANNEL_UPDATED,
    MESSAGE_INDICATION_UPDATE: EVENT_TYPES.MESSAGE_INDICATION_UPDATE,
};
var CHAT_INTERNAL_EVENTS = {
    FETCH_ENRICHED_CHATROOM_COMPLETED: 'chat.internal.events.fetchEnrichedChatroomCompleted',
    FETCH_DRILL_IN_MESSAGE_INDICATIONS_COMPLETED: 'chat.internal.events.fetchDrillInMessageIndicationsCompleted',
};
/**
 * @doc chat-event-emitter
 */
var addListener = function (eventName, callback) {
    eventEmitter.on(eventName, callback);
};
/**
 * @doc chat-event-emitter
 */
var emit = function (eventName, data) {
    eventEmitter.emit(eventName, data);
};
/**
 * @doc chat-event-emitter
 */
var removeListener = function (eventName, callback) {
    eventEmitter.removeListener(eventName, callback);
};
var removeAllListeners = function () {
    eventEmitter.removeAllListeners();
};
export var chatEventEmitter = { addListener: addListener, removeListener: removeListener, CHAT_EVENTS: CHAT_EVENTS, emit: emit };
export { CHAT_EVENTS, CHAT_INTERNAL_EVENTS, addListener, emit, removeListener, removeAllListeners };
