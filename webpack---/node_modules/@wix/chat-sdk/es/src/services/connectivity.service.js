import { __spreadArrays } from "tslib";
var ConnectivityService = /** @class */ (function () {
    function ConnectivityService() {
    }
    ConnectivityService.setConnectivityProvider = function (connectivityProvider) {
        this.connectivityProvider = connectivityProvider;
        connectivityProvider.addEventListener(this.listener.bind(this));
    };
    /**
     * Executes callback every time that network becomes available.
     * Useful for refreshing subscribed data
     * Will never be called if Connectivity Provider not supplied
     *
     * @param callback callback to execute
     */
    ConnectivityService.executeEveryTimeOnBackToOnline = function (callback) {
        var _this = this;
        if (!this.connectivityProvider) {
            return;
        }
        this.networkResumeCallbacks.push(callback);
        return function () { return _this.removeFromBackToOnline(callback); };
    };
    Object.defineProperty(ConnectivityService, "online", {
        /**
         * Returns whether or not internet is available
         * Always returns true if connectivityProvider not available
         * @returns {boolean} true if internet is available, false otherwise
         */
        get: function () {
            var _a, _b;
            return (_b = (_a = this.connectivityProvider) === null || _a === void 0 ? void 0 : _a.fetch()) !== null && _b !== void 0 ? _b : true;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Executes callback every time that network becomes unavailable.
     * Useful for disconnecting realtime services
     * Will never be called if Connectivity Provider not supplied
     *
     * @param callback callback to execute
     */
    ConnectivityService.executeEveryTimeOnOffline = function (callback) {
        var _this = this;
        if (!this.connectivityProvider) {
            return;
        }
        this.networkPauseCallbacks.push(callback);
        return function () { return _this.removeFromOnOffline(callback); };
    };
    Object.defineProperty(ConnectivityService, "waitForOnline", {
        /**
         * Returns a promise that will be resolved once network is available
         * Will be resolved immediatly if no Connectivity Provider or network already available
         *
         * @returns Promise that will be resolved when network is available
         */
        get: function () {
            var _this = this;
            if (!this.connectivityProvider || this.connectivityProvider.fetch()) {
                return Promise.resolve();
            }
            else {
                return new Promise(function (resolve) { return _this.resolveOnOnline.push(resolve); });
            }
        },
        enumerable: false,
        configurable: true
    });
    ConnectivityService.removeFromBackToOnline = function (callback) {
        this.networkResumeCallbacks.splice(this.networkResumeCallbacks.indexOf(callback), 1);
    };
    ConnectivityService.removeFromOnOffline = function (callback) {
        this.networkPauseCallbacks.splice(this.networkResumeCallbacks.indexOf(callback), 1);
    };
    ConnectivityService.listener = function (isConnected) {
        var _this = this;
        var call = function (fn) { return fn(); };
        if (isConnected) {
            return Promise.all(__spreadArrays(this.resolveOnOnline.map(call), this.networkResumeCallbacks.map(call))).then(function () { return (_this.resolveOnOnline = []); });
        }
        else {
            return Promise.all(this.networkPauseCallbacks.map(call));
        }
    };
    ConnectivityService.resolveOnOnline = [];
    ConnectivityService.networkResumeCallbacks = [];
    ConnectivityService.networkPauseCallbacks = [];
    return ConnectivityService;
}());
export default ConnectivityService;
