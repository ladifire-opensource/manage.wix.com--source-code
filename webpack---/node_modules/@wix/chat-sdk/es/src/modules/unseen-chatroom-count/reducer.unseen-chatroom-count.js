import { __assign } from "tslib";
import { combineReducers } from 'redux';
import types from '../../state/types';
import config from '../../constants/unread-chatroom-count-config';
import { shouldFilterChatroom } from '../../state/reducer/chatroomsFilter';
import { pending, success } from '../../utils/promise-middleware-utils';
export var hashUnseenFilter = function (filter) {
    return 'participantType' in filter ? filter.participantType : filter.participantId;
};
export var parseUnseenFilter = function (s) {
    return s === 'business' || s === 'siteMember' ? { participantType: s } : { participantId: s };
};
var normalize = function (chatrooms) {
    return chatrooms.reduce(function (acc, _a) {
        var chatroomId = _a.chatroomId;
        acc[chatroomId] = true;
        return acc;
    }, {});
};
var setUnseenChatrooms = function (state, action) {
    var _a;
    var payload = action.payload;
    return __assign(__assign({}, state), (_a = {}, _a[hashUnseenFilter(action.meta.filter)] = payload.length > config.maxTrackableUnreads
        ? { resyncCountdown: config.maxTrackableUnreads - config.maxUnreadsCount }
        : { chatrooms: normalize(payload) }, _a));
};
var getMatchedFilters = function (state, chatroom) {
    return Object.keys(state)
        .map(parseUnseenFilter)
        .filter(function (filter) {
        return shouldFilterChatroom(chatroom, 'participantId' in filter
            ? { participantIds: [filter.participantId] }
            : { participantType: filter.participantType });
    })
        .map(hashUnseenFilter);
};
var isOverflow = function (state) {
    return 'resyncCountdown' in state;
};
var setChatroomAsUnseenInFilter = function (state, chatroomId) {
    var _a;
    if (isOverflow(state)) {
        return state;
    }
    if (Object.keys(state.chatrooms).length === config.maxTrackableUnreads) {
        return {
            resyncCountdown: config.maxTrackableUnreads - config.maxUnreadsCount,
        };
    }
    return {
        chatrooms: __assign(__assign({}, state.chatrooms), (_a = {}, _a[chatroomId] = true, _a)),
    };
};
var setChatroomAsUnseen = function (state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var matchedFilters = getMatchedFilters(state, chatroom);
    var newState = __assign({}, state);
    matchedFilters.forEach(function (filterHash) {
        newState[filterHash] = setChatroomAsUnseenInFilter(state[filterHash], chatroom.id);
    });
    return newState;
};
var setChatroomAsSeenInFilter = function (state, chatroomId) {
    if (isOverflow(state)) {
        return {
            resyncCountdown: Math.max(0, state.resyncCountdown - 1),
        };
    }
    if (state.chatrooms[chatroomId]) {
        var chatrooms = __assign({}, state.chatrooms);
        delete chatrooms[chatroomId];
        return { chatrooms: chatrooms };
    }
    return state;
};
var setChatroomIdAsSeen = function (state, chatroomId) {
    var filters = Object.keys(state);
    var newState = __assign({}, state);
    filters.forEach(function (filterHash) {
        newState[filterHash] = setChatroomAsSeenInFilter(state[filterHash], chatroomId);
    });
    return newState;
};
var setChatroomAsSeen = function (state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var matchedFilters = getMatchedFilters(state, chatroom);
    var newState = __assign({}, state);
    matchedFilters.forEach(function (filterHash) {
        newState[filterHash] = setChatroomAsSeenInFilter(state[filterHash], chatroom.id);
    });
    return newState;
};
var byFilter = function (state, action) {
    var _a;
    if (state === void 0) { state = {}; }
    switch (action.type) {
        case success(types.SET_UNSEEN_CHATROOMS):
            return setUnseenChatrooms(state, action);
        case types.ADD_MESSAGE: {
            var _b = action.meta.chatroom, _c = _b === void 0 ? {} : _b, _d = _c.lastSeenMessageSequence, lastSeenMessageSequence = _d === void 0 ? 0 : _d, _e = _c.lastReadMessageSequence, lastReadMessageSequence = _e === void 0 ? 0 : _e;
            var lastReadOrSeenSequence = Math.max(lastSeenMessageSequence, lastReadMessageSequence);
            return action.messageSentByCurrentUser ||
                action.message.isSilent ||
                action.message.sequence <= lastReadOrSeenSequence
                ? state
                : setChatroomAsUnseen(state, action.meta.chatroom);
        }
        case types.HANDLE_ROOM_UNARCHIVED:
        case types.UNARCHIVE_ROOM:
        case types.SET_LAST_MESSAGE_UNREAD:
            return setChatroomAsUnseen(state, action.meta.chatroom);
        case types.UNARCHIVE_ROOMS:
            return action.meta.chatrooms.reduce(function (prev, chatroom) { return setChatroomAsUnseen(prev, chatroom); }, state);
        case types.MARK_CHATROOM_SEEN:
            return setChatroomAsSeen(state, action.meta.chatroom);
        case pending(types.MARK_CHATROOMS_SEEN): {
            var _f = action.meta, filter = _f.filter, filteredChatrooms = _f.filteredChatrooms;
            var filterHash = hashUnseenFilter(filter);
            var filteredState = state[filterHash];
            var chatroomIds = isOverflow(filteredState) ? [] : Object.keys(filteredState.chatrooms);
            return __assign(__assign(__assign({}, filteredChatrooms.reduce(function (prev, chatroom) {
                return setChatroomAsSeen(prev, chatroom);
            }, state)), chatroomIds.reduce(function (prev, chatroomId) { return setChatroomIdAsSeen(prev, chatroomId); }, state)), (_a = {}, _a[filterHash] = {
                chatrooms: {},
            }, _a));
        }
        default:
            return state;
    }
};
export var unseenChatroomCountReducer = combineReducers({
    byFilter: byFilter,
});
