import { __awaiter, __generator } from "tslib";
import types from '../../state/types';
import config from '../../constants/unread-chatroom-count-config';
import { getFilteredUnseenChatrooms, getLastKnownMessageSequence } from '../../state/reducer/selector.chatrooms';
import _unionBy from 'lodash/unionBy';
import { filterChatrooms } from '../../state/reducer/chatroomsFilter';
import { isChatroomUnseen } from './selector.unseen-chatroom-count';
import { parseUnseenFilter } from './reducer.unseen-chatroom-count';
var mergeUnseens = function (filter, unseenChatrooms, state) {
    return _unionBy(unseenChatrooms.chatrooms.filter(function (_a) {
        var chatroomId = _a.chatroomId;
        var chatroom = state.chatrooms.byId[chatroomId];
        if (!chatroom) {
            return true;
        }
        return isChatroomUnseen(chatroom);
    }), getFilteredUnseenChatrooms(state, filter), function (chatroom) { return chatroom.chatroomId; });
};
var shouldResync = function (prevState, newState) {
    return prevState &&
        newState &&
        'resyncCountdown' in prevState &&
        'resyncCountdown' in newState &&
        prevState.resyncCountdown === 1 &&
        newState.resyncCountdown === 0;
};
var UnseenChatroomCountActions = /** @class */ (function () {
    function UnseenChatroomCountActions(serverApi) {
        this.serverApi = serverApi;
    }
    UnseenChatroomCountActions.prototype.updateUnseenChatrooms = function (filter) {
        var _this = this;
        return function (dispatch, getState) {
            var fetchAndMergeUnseenChatrooms = function () { return __awaiter(_this, void 0, void 0, function () {
                var _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = mergeUnseens;
                            _b = [filter];
                            return [4 /*yield*/, this.serverApi.http$fetchUnseenChatroomCount(filter, config.maxTrackableUnreads + 1)];
                        case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent(), getState()]))];
                    }
                });
            }); };
            return dispatch({
                type: types.SET_UNSEEN_CHATROOMS,
                payload: fetchAndMergeUnseenChatrooms(),
                meta: {
                    filter: filter,
                },
            });
        };
    };
    UnseenChatroomCountActions.prototype.markChatroomAsSeen = function (chatroomId) {
        var _this = this;
        return function (dispatch, getState) {
            var prevState = getState();
            dispatch({
                type: types.MARK_CHATROOM_SEEN,
                payload: chatroomId,
                meta: {
                    chatroom: getState().chatrooms.byId[chatroomId],
                },
            });
            return Promise.all(Object.keys(prevState.unseenChatroomCount.byFilter)
                .filter(function (filter) {
                return shouldResync(prevState.unseenChatroomCount.byFilter[filter], getState().unseenChatroomCount.byFilter[filter]);
            })
                .map(function (filter) {
                return dispatch(_this.updateUnseenChatrooms(parseUnseenFilter(filter)));
            }));
        };
    };
    UnseenChatroomCountActions.prototype.markChatroomsAsSeen = function (filter) {
        var _this = this;
        return function (dispatch, getState) {
            return dispatch({
                type: types.MARK_CHATROOMS_SEEN,
                payload: _this.serverApi.http$markChatroomsAsSeen(filter, getLastKnownMessageSequence(getState())),
                meta: {
                    filter: filter,
                    filteredChatrooms: Object.values(filterChatrooms(getState().chatrooms.byId, 'participantId' in filter
                        ? { participantIds: [filter.participantId] }
                        : { participantType: filter.participantType })),
                },
            });
        };
    };
    return UnseenChatroomCountActions;
}());
export default UnseenChatroomCountActions;
