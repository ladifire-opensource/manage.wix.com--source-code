import { __assign } from "tslib";
import { combineReducers } from 'redux';
import types from '../../state/types';
import { success } from '../../utils/promise-middleware-utils';
var normalize = function (chatroomIds) {
    if (!chatroomIds) {
        return {};
    }
    return chatroomIds.reduce(function (acc, chatroomId) {
        acc[chatroomId] = true;
        return acc;
    }, {});
};
var setUnreadChatrooms = function (state, action) {
    var chatroomsForParticipant = action.payload.chatroomsForParticipant;
    var participantIds = action.meta.filter.participantIds || Object.keys(chatroomsForParticipant);
    return participantIds.reduce(function (acc, participantId) {
        var chatrooms = normalize(chatroomsForParticipant[participantId]);
        acc[participantId] = { chatrooms: chatrooms };
        return acc;
    }, state);
};
var setChatroomReadState = function (state, chatroom) {
    if (!chatroom) {
        return state;
    }
    var newState = __assign({}, state);
    var currentFilter = state[chatroom.participantId];
    if (currentFilter) {
        var chatrooms = currentFilter.chatrooms;
        if (chatrooms[chatroom.id]) {
            delete chatrooms[chatroom.id];
        }
    }
    return newState;
};
var setChatroomUnreadStateIfUnread = function (state, chatroom) {
    var _a, _b;
    var roomIsUnread = ((_a = chatroom.lastMessage) === null || _a === void 0 ? void 0 : _a.sequence) && ((_b = chatroom.lastMessage) === null || _b === void 0 ? void 0 : _b.sequence) > chatroom.lastReadMessageSequence;
    if (roomIsUnread) {
        return setChatroomUnreadState(state, chatroom);
    }
    else {
        return state;
    }
};
var setChatroomUnreadState = function (state, chatroom) {
    var _a;
    if (!chatroom) {
        return state;
    }
    var newState = __assign({}, state);
    var currentFilter = state[chatroom.participantId];
    newState[chatroom.participantId] = __assign(__assign({}, currentFilter), { chatrooms: __assign(__assign({}, currentFilter === null || currentFilter === void 0 ? void 0 : currentFilter.chatrooms), (_a = {}, _a[chatroom.id] = true, _a)) });
    return newState;
};
var byFilter = function (state, action) {
    if (state === void 0) { state = {}; }
    switch (action.type) {
        case success(types.SET_UNREAD_CHATROOMS_MAP):
            return setUnreadChatrooms(state, action);
        case types.ADD_MESSAGE: {
            var _a = action.meta.chatroom, _b = (_a === void 0 ? {} : _a).lastReadMessageSequence, lastReadMessageSequence = _b === void 0 ? 0 : _b;
            return action.messageSentByCurrentUser ||
                action.message.isSilent ||
                action.message.sequence <= lastReadMessageSequence
                ? state
                : setChatroomUnreadState(state, action.meta.chatroom);
        }
        case types.HANDLE_ROOM_UNARCHIVED:
            return setChatroomUnreadStateIfUnread(state, action.meta.chatroom);
        case success(types.SET_LAST_MESSAGE_UNREAD):
            return setChatroomUnreadState(state, action.meta.chatroom);
        case success(types.UNARCHIVE_ROOM):
            return setChatroomUnreadStateIfUnread(state, unarchive(action.meta.chatroom));
        case success(types.UNARCHIVE_ROOMS):
            return action.meta.chatrooms.reduce(function (prev, chatroom) { return setChatroomUnreadStateIfUnread(prev, unarchive(chatroom)); }, state);
        case types.MARK_CHATROOM_READ:
            return setChatroomReadState(state, action.meta.chatroom);
        case success(types.SET_MESSAGES_READ):
            return setChatroomReadState(state, action.meta.chatroom);
        default:
            return state;
    }
};
var unarchive = function (room) { return (__assign(__assign({}, room), { isArchived: false })); };
export var unreadChatroomCountReducer = combineReducers({
    byFilter: byFilter,
});
