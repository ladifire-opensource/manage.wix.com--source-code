import { __assign, __awaiter, __generator } from "tslib";
import * as chatEventEmitter from '../services/chat-event-emitter.service';
import EVENT_TYPES from './event-types.constants';
import * as constants from '../constants/constants';
import presenceActions from '../presence/action.presence';
import { chatSdk } from '../api/chat-sdk';
var chatroomHasBeenLoaded = function (chatroomsById, chatroomId) { var _a, _b; return (_b = (_a = chatroomsById[chatroomId]) === null || _a === void 0 ? void 0 : _a.displayData) === null || _b === void 0 ? void 0 : _b.name; };
var onAddRealtimeMessage = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, data = _a.data, currentUser = _a.currentUser;
    return __awaiter(void 0, void 0, void 0, function () {
        var chatroomId, message, connectionEstablishedTimestamp, timestamp, chatrooms, chatroomsById, isEnrichedChatroom, fetchPromise, messageSentByCurrentUser, messageWithSendStatusSent, didConnectionEstablishFewSecondBeforeSendingMessage;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    chatroomId = data.chatroomId, message = data.message, connectionEstablishedTimestamp = data.connectionEstablishedTimestamp, timestamp = data.timestamp;
                    chatrooms = store.getState().chatrooms;
                    chatroomsById = chatrooms.byId;
                    if (!!chatroomHasBeenLoaded(chatroomsById, chatroomId)) return [3 /*break*/, 2];
                    if (!chatroomId) {
                        console.error('[Troubleshoot] onAddRealtimeMessage calling fetchRoom w/o chatroomId' + JSON.stringify(data));
                    }
                    isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
                    fetchPromise = store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
                    if (!chatSdk.isExperimentOn(constants.experiments.UnseenChatroomCount)) return [3 /*break*/, 2];
                    return [4 /*yield*/, fetchPromise];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    chatroomsById = store.getState().chatrooms.byId;
                    messageSentByCurrentUser = currentUser.userId === message.sender.userId;
                    messageWithSendStatusSent = __assign(__assign({}, message), { transit: __assign(__assign({}, message.transit), { sendStatus: constants.MessageSendStatus.SENT }) });
                    store.dispatch(chatroomsActions.action$addMessage(messageWithSendStatusSent, messageSentByCurrentUser, chatroomsById[chatroomId]));
                    didConnectionEstablishFewSecondBeforeSendingMessage = timestamp + constants.HistorySinceRealtimeConnectionWasEstablished >= connectionEstablishedTimestamp;
                    if (!messageSentByCurrentUser && didConnectionEstablishFewSecondBeforeSendingMessage) {
                        _postOnRealtimeMessageEvent(message);
                    }
                    return [2 /*return*/];
            }
        });
    });
};
var deleteChatroom = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, data = _a.data;
    return store.dispatch(chatroomsActions.action$removeRoom(data.chatroomId));
};
var handlePresenceEvent = function (store, data) { return store.dispatch(presenceActions.action$updatePresence(data)); };
var refreshChatroom = function (_a, force) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, chatroomId = _a.chatroomId, dataForDebug = _a.dataForDebug;
    if (force === void 0) { force = false; }
    if (!chatroomId) {
        // TODO: remove when error is resolved: https://sentry.io/wix_o/wix-one-app/issues/718628954/events/36573747091/
        console.error('[Troubleshoot] refreshChatroom: ' + JSON.stringify(dataForDebug));
    }
    var isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
    return store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom, force));
};
var refreshChatrooms = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, data = _a.data;
    return data.chatroomIds.forEach(function (chatroomId) {
        return refreshChatroom({ store: store, chatroomsActions: chatroomsActions, chatroomId: chatroomId, dataForDebug: data });
    });
};
var changeTypingStatus = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, data = _a.data, currentUser = _a.currentUser;
    var chatroomId = data.chatroomId, userId = data.userId, type = data.type, displayDataDto = data.displayData, timestamp = data.timestamp, connectionEstablishedTimestamp = data.connectionEstablishedTimestamp;
    if (connectionEstablishedTimestamp > timestamp) {
        return;
    }
    var displayData = null;
    if (type === EVENT_TYPES.TYPING_STARTED && displayDataDto) {
        displayData = {
            imageUrl: displayDataDto.content.image ? displayDataDto.content.image.url : undefined,
            initials: displayDataDto.content.initials,
            id: displayDataDto.content.id,
            name: displayDataDto.content.name,
            type: displayDataDto.content.type,
        };
    }
    var isCurrentUser = userId === currentUser.userId;
    store.dispatch(chatroomsActions.action$changeTypingStatus({ chatroomId: chatroomId, userId: userId, type: type, displayData: displayData, isCurrentUser: isCurrentUser }));
};
var _stopTypingTimers = {};
var stopTypingAfterInterval = function (_a) {
    var data = _a.data, store = _a.store, chatroomsActions = _a.chatroomsActions;
    var userId = data.userId, chatroomId = data.chatroomId, expiryDuration = data.expiryDuration;
    if (expiryDuration) {
        var timerId = userId + "|" + chatroomId;
        if (_stopTypingTimers[timerId]) {
            clearTimeout(_stopTypingTimers[timerId]);
        }
        _stopTypingTimers[timerId] = setTimeout(function () {
            store.dispatch(chatroomsActions.action$changeTypingStatus({ chatroomId: chatroomId, userId: userId, type: EVENT_TYPES.TYPING_STOPPED }));
        }, expiryDuration);
    }
};
var changeRoomArchivalStatus = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, chatroomId = _a.chatroomId, isArchived = _a.isArchived;
    var byId = store.getState().chatrooms.byId;
    if (!chatroomHasBeenLoaded(byId, chatroomId)) {
        var isEnrichedChatroom = chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom);
        store.dispatch(chatroomsActions.action$fetchRoom(chatroomId, isEnrichedChatroom));
        return;
    }
    store.dispatch(isArchived
        ? chatroomsActions.action$handleRoomArchived(chatroomId)
        : chatroomsActions.action$handleRoomUnarchived(chatroomId));
};
var onChatroomReadForSelf = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, chatroomId = _a.chatroomId, userId = _a.userId, sequenceToMarkAsRead = _a.sequenceToMarkAsRead;
    if (chatSdk.getUserId() === userId) {
        store.dispatch(chatroomsActions.action$setMessagesReadForSelf(chatroomId, sequenceToMarkAsRead));
    }
};
var updateMessagesIndications = function (_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, messagesActions = _a.messagesActions, data = _a.data;
    var participants = store.getState().participants;
    if (!participants.byId[data.participantId]) {
        store.dispatch(chatroomsActions.action$fetchRoomParticipantsDisplayData(data.chatroomId, [data.participantId]));
    }
    store.dispatch(messagesActions.action$updateMessagesIndications({
        chatroomId: data.chatroomId,
        messageIds: data.messageIds,
        participantId: data.participantId,
        indication: data.indication,
    }));
};
function onRealtimeEvent(_a) {
    var store = _a.store, chatroomsActions = _a.chatroomsActions, messagesActions = _a.messagesActions, data = _a.data, currentUser = _a.currentUser;
    // See https://github.com/wix-private/chat-server/tree/master/chat/chat-api#events for payloads
    switch (data.type) {
        case EVENT_TYPES.MESSAGE_SENT:
            return onAddRealtimeMessage({ store: store, chatroomsActions: chatroomsActions, data: data, currentUser: currentUser });
        case EVENT_TYPES.MESSAGE_DELETED:
            return store.dispatch(chatroomsActions.action$deleteMessage(data.messageId));
        case EVENT_TYPES.CHATROOM_DELETED:
            return deleteChatroom({ store: store, chatroomsActions: chatroomsActions, data: data });
        case EVENT_TYPES.CHATROOOM_DISPLAY_DATA_UPDATED:
            return refreshChatrooms({ store: store, chatroomsActions: chatroomsActions, data: data });
        case EVENT_TYPES.LABEL_ADDED:
            return store.dispatch(chatroomsActions.action$updateRoomLabels(data));
        case EVENT_TYPES.LABEL_REMOVED:
            return store.dispatch(chatroomsActions.action$removeRoomLabels(data.chatroomParticipantLabel));
        case EVENT_TYPES.CHATROOM_CREATED:
            return refreshChatroom({ store: store, chatroomsActions: chatroomsActions, chatroomId: data.chatroomId, dataForDebug: data });
        case EVENT_TYPES.OFFLINE_CHANNEL_UPDATED:
            chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.OFFLINE_CHANNEL_UPDATED, data);
            return refreshChatroom({ store: store, chatroomsActions: chatroomsActions, chatroomId: data.chatroomId, dataForDebug: data });
        case EVENT_TYPES.CHATROOM_MERGED:
            return refreshChatroom({ store: store, chatroomsActions: chatroomsActions, chatroomId: data.toChatroomId, dataForDebug: data }, true);
        case EVENT_TYPES.TYPING_STARTED:
            stopTypingAfterInterval({ store: store, chatroomsActions: chatroomsActions, data: data }); //do not break! intentionally fall through to typing stopped
        case EVENT_TYPES.TYPING_STOPPED:
            return changeTypingStatus({ store: store, chatroomsActions: chatroomsActions, data: data, currentUser: currentUser });
        case EVENT_TYPES.CHATROOM_ARCHIVED:
            return changeRoomArchivalStatus({ store: store, chatroomsActions: chatroomsActions, chatroomId: data.chatroomId, isArchived: true });
        case EVENT_TYPES.CHATROOM_UNARCHIVED:
            return changeRoomArchivalStatus({ store: store, chatroomsActions: chatroomsActions, chatroomId: data.chatroomId, isArchived: false });
        case EVENT_TYPES.CHATROOM_READ:
            return onChatroomReadForSelf({
                store: store,
                chatroomsActions: chatroomsActions,
                chatroomId: data.chatroomId,
                userId: data.userId,
                sequenceToMarkAsRead: data.lastReadMessageSequence,
            });
        case EVENT_TYPES.CHATROOMS_ALL_READ:
            return chatSdk.setAllRoomsAsRead({ participantIds: data.participantIds }, false);
        case EVENT_TYPES.CHATROOM_UNREAD:
            return store.dispatch(chatroomsActions.action$setLastMessageUnread(data.chatroomId, data.lastReadMessageSequence, false));
        case EVENT_TYPES.MESSAGE_INDICATION_UPDATE:
            chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.MESSAGE_INDICATION_UPDATE, data);
            if (chatSdk.isExperimentOn(constants.experiments.EnrichedChatroom)) {
                return updateMessagesIndications({ store: store, chatroomsActions: chatroomsActions, messagesActions: messagesActions, data: data });
            }
            break;
        case EVENT_TYPES.PRESENCE_EVENT:
            return handlePresenceEvent(store, data);
        case EVENT_TYPES.EXTERNAL_HOST:
            chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.EXTERNAL_HOST, data);
            break;
        default:
            return;
    }
}
var _postOnRealtimeMessageEvent = function (message) {
    chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.NEW_REALTIME_MESSAGE, message);
};
export { onRealtimeEvent, EVENT_TYPES };
