import { __assign, __awaiter, __generator } from "tslib";
import * as constants from '../constants/constants';
import { CHAT_EVENTS } from '../services/chat-event-emitter.service';
import { chatSdk, chatEventEmitter } from '../index';
export var realtimeClientFactory = function (firebaseService) {
    return ({
        connect: function (_a) {
            var realtimeServiceSetup = _a.realtimeServiceSetup, onEvent = _a.onEvent, _b = _a.eventHooks, eventHooks = _b === void 0 ? defaultEventHooks : _b;
            return __awaiter(this, void 0, void 0, function () {
                var reportSuccess, reportFail, options, authKey, eventsPath, errorMessage, onEventWrapper, serverTimePath, serverTime_1, ex_1;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            reportSuccess = function () {
                                var event = { tag: 'realtime', description: 'onConnect success' };
                                chatEventEmitter.emit(CHAT_EVENTS.MONITORING_BI, event);
                                return eventHooks.reportMonitoringBi(event);
                            };
                            reportFail = function (message) {
                                var event = { tag: 'realtime', description: "onConnect failure " + message };
                                chatEventEmitter.emit(CHAT_EVENTS.MONITORING_BI, event);
                                return eventHooks.reportMonitoringBi(event);
                            };
                            options = realtimeServiceSetup.options, authKey = realtimeServiceSetup.authKey, eventsPath = realtimeServiceSetup.eventsPath;
                            if (!eventsPath) {
                                errorMessage = 'chat-sdk.realtime.client: unexpected data received';
                                console.error(errorMessage, realtimeServiceSetup);
                                throw new Error(errorMessage);
                            }
                            onEventWrapper = function (_a, serverTime) {
                                var value = _a.value;
                                setTimeout(function () {
                                    try {
                                        var internal = JSON.stringify(value);
                                        eventHooks.reportMonitoringBi({ tag: 'realtime', description: "RT Event: " + value.type, internal: internal });
                                    }
                                    catch (e) {
                                        console.error("Error parsing RT event value: " + value);
                                    }
                                }, 0);
                                onEvent(__assign(__assign({}, value), { connectionEstablishedTimestamp: serverTime }));
                            };
                            serverTimePath = eventsPath.split('/').slice(0, -1).join('/') + '/timestamp';
                            _c.label = 1;
                        case 1:
                            _c.trys.push([1, 4, , 5]);
                            return [4 /*yield*/, firebaseService.connect(options, authKey)];
                        case 2:
                            _c.sent();
                            return [4 /*yield*/, firebaseService.getFirebaseServerTime(serverTimePath)];
                        case 3:
                            serverTime_1 = _c.sent();
                            firebaseService
                                .listenOnPath(eventsPath, { orderBy: 'timestamp', startAt: getStartAtTime(serverTime_1) })
                                .when('child_added')
                                .call(function (_a) {
                                var value = _a.value;
                                return onEventWrapper({ value: value }, serverTime_1);
                            });
                            firebaseService
                                .listenOnPath(eventsPath, { orderBy: 'timestamp', startAt: getStartAtTime(serverTime_1) })
                                .when('child_changed')
                                .call(function (_a) {
                                var value = _a.value;
                                return onEventWrapper({ value: value }, serverTime_1);
                            });
                            reportSuccess();
                            return [3 /*break*/, 5];
                        case 4:
                            ex_1 = _c.sent();
                            reportFail(ex_1);
                            throw ex_1;
                        case 5: return [2 /*return*/];
                    }
                });
            });
        },
        disconnect: function () {
            firebaseService.disconnect();
        },
    });
};
var defaultEventHooks = {
    reportMonitoringBi: function () { },
};
function getStartAtTime(serverTime) {
    /*
    NoHistoryOnRealtimeConnect should not be opened for users.
    It exists to help automation,
    fixing a bug where conversation delete + quick reload make deleted conversation appear again.
    For users we want to fetch some history from Firebase so we can get messages sent in close proximity to launch
    (e.g. opening from push notification on mobile)
    More info on Jira at CHAT-2152
    */
    return chatSdk.isExperimentOn(constants.experiments.NoHistoryOnRealtimeConnect)
        ? serverTime
        : serverTime - constants.HistorySinceRealtimeConnectionWasEstablished;
}
