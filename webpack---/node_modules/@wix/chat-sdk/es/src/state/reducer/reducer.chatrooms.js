import { __assign, __spreadArrays } from "tslib";
import { default_lastReadMessageSequence, default_lastSeenMessageSequence, default_unreadCount, } from '../../defaults/defaults';
import { combineReducers } from 'redux';
import _get from 'lodash/get';
import _omit from 'lodash/omit';
import _isEmpty from 'lodash/isEmpty';
import _pickBy from 'lodash/pickBy';
import _without from 'lodash/without';
import EVENT_TYPES from '../../realtime/event-types.constants';
import { error, pending, success } from '../../utils/promise-middleware-utils';
import { areAllMessagesNew } from '../helpers/messages.helper';
import types from '../types';
var initialState = {};
var initialFiltersBySubscriberIdState = {};
var EmptyTypingStatus = [];
var processedClusterActions = {};
var mergeSequences = function (newLastReadMessageSequence, currentLastReadMessageSequence, forceUpdate) {
    if (forceUpdate === void 0) { forceUpdate = false; }
    if (forceUpdate) {
        return newLastReadMessageSequence;
    }
    //The || default_lastSeenMessageSequence are here until we make all of the reducer function go trough mergeRoom which sets defaults value
    // so that no field will be undefined (causing this function to return 'NaN')
    return Math.max(newLastReadMessageSequence || default_lastReadMessageSequence, currentLastReadMessageSequence || default_lastReadMessageSequence);
};
var mergeUnreads = function (newUnreadCount, currentUnreadCount, newLastReadMessageSequence, currentLastReadMessageSequence, forceUpdate) {
    if (forceUpdate === void 0) { forceUpdate = false; }
    if (forceUpdate) {
        return newUnreadCount;
    }
    //The || default_lastSeenMessageSequence are here until we make all of the reducer function go trough mergeRoom which sets defaults value
    // so that no field will be undefined (causing this function to return 'NaN')
    return (currentLastReadMessageSequence || default_lastReadMessageSequence) >
        (newLastReadMessageSequence || default_lastReadMessageSequence)
        ? currentUnreadCount
        : newUnreadCount;
};
var stateValueOrDefault = function (state, chatroomId, fieldName, defaultValue) {
    if (!state[chatroomId]) {
        return defaultValue;
    }
    if (typeof state[chatroomId][fieldName] === 'undefined') {
        return defaultValue;
    }
    return state[chatroomId][fieldName];
};
var mergeRoomFromStorage = function (state, room) {
    var _a;
    var chatroomId = room.id;
    var mergedRoom = mergeRoom(state, room)[chatroomId];
    var roomStateFields = room;
    var mergedRoomWithStateFields = __assign(__assign({}, mergedRoom), _pickBy(roomStateFields, function (v) { return v !== null; }));
    return __assign(__assign({}, state), (_a = {}, _a[chatroomId] = mergedRoomWithStateFields, _a));
};
var removeKeysIfEmpty = function (mergedRoom, keys) {
    return keys.forEach(function (key) { return mergedRoom[key] === undefined && delete mergedRoom[key]; });
};
var MergeRoomOptionsDefault = {
    enrichedChatroomLoaded: false,
    typingEvent: {},
    overrideRegardlessOfSequenceComparison: false,
};
var mergeRoom = function (state, dto, participants, mergeRoomOptions) {
    var _a;
    if (participants === void 0) { participants = []; }
    if (mergeRoomOptions === void 0) { mergeRoomOptions = MergeRoomOptionsDefault; }
    var chatroomId = dto.id;
    var _b = __assign(__assign({}, MergeRoomOptionsDefault), mergeRoomOptions), enrichedChatroomLoaded = _b.enrichedChatroomLoaded, typingEvent = _b.typingEvent, overrideRegardlessOfSequenceComparison = _b.overrideRegardlessOfSequenceComparison;
    var participantId = dto.participantId, lastMessage = dto.lastMessage, _c = dto.unreadCount, unreadCount = _c === void 0 ? stateValueOrDefault(state, chatroomId, 'unreadCount', default_unreadCount) : _c, _d = dto.lastReadMessageSequence, lastReadMessageSequence = _d === void 0 ? stateValueOrDefault(state, chatroomId, 'lastReadMessageSequence', default_lastReadMessageSequence) : _d, _e = dto.lastSeenMessageSequence, lastSeenMessageSequence = _e === void 0 ? stateValueOrDefault(state, chatroomId, 'lastSeenMessageSequence', default_lastSeenMessageSequence) : _e, displayData = dto.displayData, isPrivate = dto.isPrivate, offlineChannels = dto.offlineChannels, clientReferenceType = dto.clientReferenceType, clientReference = dto.clientReference, participantCount = dto.participantCount, isArchived = dto.isArchived, isTemporary = dto.isTemporary, createdBy = dto.createdBy, createdAt = dto.createdAt, businessContext = dto.businessContext, pluginName = dto.pluginName, sortRank = dto.sortRank, labelIds = dto.labelIds, lastMessages = dto.lastMessages;
    var currentRooms = state;
    var roomBeforeMerge = currentRooms[chatroomId] || {
        unreadCount: unreadCount,
        lastReadMessageSequence: lastReadMessageSequence,
        lastSeenMessageSequence: lastSeenMessageSequence,
    };
    var currentTypingStatus = roomBeforeMerge.typingStatus || EmptyTypingStatus;
    var newTypingStatus = mergeTypingEventIntoTypingStatus(currentTypingStatus, typingEvent);
    var isNewParticipantExists = participants && participants.length > 0;
    var isOldParticipantExists = roomBeforeMerge.participants !== undefined;
    var mergedRoom = {
        displayData: displayData ? __assign(__assign({}, roomBeforeMerge.displayData), displayData) : roomBeforeMerge.displayData,
        id: chatroomId,
        cursor: roomBeforeMerge.cursor,
        lastMessage: lastMessage || roomBeforeMerge.lastMessage,
        lastMessages: lastMessages || roomBeforeMerge.lastMessages,
        lastReadMessageSequence: mergeSequences(lastReadMessageSequence, roomBeforeMerge.lastReadMessageSequence, overrideRegardlessOfSequenceComparison),
        lastSeenMessageSequence: mergeSequences(lastSeenMessageSequence, roomBeforeMerge.lastSeenMessageSequence),
        unreadCount: mergeUnreads(unreadCount, roomBeforeMerge.unreadCount, lastReadMessageSequence, roomBeforeMerge.lastReadMessageSequence, overrideRegardlessOfSequenceComparison),
        typingStatus: newTypingStatus,
        isPrivate: isPrivate !== undefined ? isPrivate : roomBeforeMerge.isPrivate,
        clientReferenceType: clientReferenceType || roomBeforeMerge.clientReferenceType,
        clientReference: clientReference || roomBeforeMerge.clientReference,
        offlineChannels: offlineChannels || roomBeforeMerge.offlineChannels,
        participantCount: typeof participantCount !== 'undefined' ? participantCount : roomBeforeMerge.participantCount,
        isArchived: isArchived !== undefined ? isArchived : roomBeforeMerge.isArchived,
        participantId: participantId !== undefined ? participantId : roomBeforeMerge.participantId,
        isTemporary: isTemporary !== undefined ? isTemporary : roomBeforeMerge.isTemporary,
        createdBy: typeof createdBy !== 'undefined' ? createdBy : roomBeforeMerge.createdBy,
        createdAt: typeof createdAt !== 'undefined' ? createdAt : roomBeforeMerge.createdAt,
        businessContext: businessContext || roomBeforeMerge.businessContext,
        enrichedChatroomLoaded: enrichedChatroomLoaded || roomBeforeMerge.enrichedChatroomLoaded,
        pluginName: pluginName || roomBeforeMerge.pluginName,
        sortRank: sortRank || roomBeforeMerge.sortRank,
        participants: isNewParticipantExists || !isOldParticipantExists ? participants : roomBeforeMerge.participants,
        labelIds: labelIds || roomBeforeMerge.labelIds,
        messageDeliveryError: roomBeforeMerge.messageDeliveryError,
    };
    removeKeysIfEmpty(mergedRoom, ['image', 'enrichedChatroomLoaded', 'messageDeliveryError']);
    var updatedCurrentRooms = __assign(__assign({}, currentRooms), (_a = {}, _a[chatroomId] = __assign(__assign({}, roomBeforeMerge), mergedRoom), _a));
    return __assign(__assign({}, state), updatedCurrentRooms);
};
var addOrRemoveToArray = function (arr, item, remove) {
    if (arr === void 0) { arr = []; }
    if (remove === void 0) { remove = false; }
    return remove ? _without(arr, item) : arr.concat(item);
};
var mergeLabelsToChatrooms = function (state, payload, remove) {
    if (remove === void 0) { remove = false; }
    var updatedRooms = payload.reduce(function (acc, _a) {
        var _b;
        var chatroomId = _a.chatroomId, labelId = _a.labelId;
        var currentChatroom = __assign(__assign({}, state[chatroomId]), (acc[chatroomId] || {}));
        return currentChatroom
            ? __assign(__assign({}, acc), (_b = {}, _b[chatroomId] = __assign(__assign({}, currentChatroom), { labelIds: addOrRemoveToArray(currentChatroom.labelIds, labelId, remove) }), _b)) : acc;
    }, {});
    return __assign(__assign({}, state), updatedRooms);
};
var fetchRooms = function (state, action, overwriteExisting) {
    var isFetchingFromStorage = _get(action, 'meta.fromStorage', false);
    if (_isEmpty(action.payload)) {
        // this can happen when cache is empty or if we got en error while fetching from cache
        return state;
    }
    var chatroomData = action.payload.chatrooms;
    var rooms = chatroomData.items;
    var newState = state;
    rooms.forEach(function (room) {
        var roomAlreadyExistInState = !!state[room.id];
        if (!roomAlreadyExistInState || overwriteExisting) {
            if (!isFetchingFromStorage) {
                newState = mergeRoom(newState, room);
            }
            else {
                newState = mergeRoomFromStorage(newState, room);
            }
        }
    });
    return newState;
};
var addRooms = function (state, rooms) {
    var newState = state;
    rooms.forEach(function (room) {
        newState = mergeRoom(newState, room);
    });
    return newState;
};
var unarchiveRoom = function (state, chatroomId) { return setArchiveState(state, chatroomId, false); };
var archiveRoom = function (state, chatroomId) { return setArchiveState(state, chatroomId, true); };
var setArchiveState = function (state, chatroomId, isArchived) {
    return mergeRoom(state, {
        id: chatroomId,
        isArchived: isArchived,
    });
};
var addMessage = function (state, action) {
    var message = action.message;
    var isSilent = message.isSilent;
    var stateChatroom = state[message.chatroomId];
    if (!stateChatroom || isSilent) {
        return state;
    }
    var isNewerMessage = message.sequence > _get(stateChatroom, 'lastMessage.sequence', 0);
    var stateWithUpdatedLastMessage = updateLastMessage(state, message);
    if (action.messageSentByCurrentUser) {
        if (isNewerMessage) {
            return setRoomRead(stateWithUpdatedLastMessage, message.chatroomId);
        }
        return stateWithUpdatedLastMessage;
    }
    else if (isNewerMessage) {
        return incrementUnreadCount(stateWithUpdatedLastMessage, message.chatroomId);
    }
    else {
        return state;
    }
};
var incrementUnreadCount = function (state, chatroomId) {
    return mergeRoom(state, {
        id: chatroomId,
        unreadCount: (state[chatroomId].unreadCount || default_unreadCount) + 1,
        lastReadMessageSequence: state[chatroomId].lastReadMessageSequence,
    });
};
var updateLastMessage = function (state, lastMessage) {
    return mergeRoom(state, {
        id: lastMessage.chatroomId,
        lastMessage: lastMessage,
    });
};
function isStaleRoomLastMessage(fetchedRoom, state) {
    var currentRoom = state[fetchedRoom.id];
    return _get(fetchedRoom, 'lastMessages.0.sequence') < _get(currentRoom, 'lastMessages.0.sequence');
}
function fetchRoomMessagesSuccess(state, action) {
    if (_isEmpty(action.payload)) {
        return state;
    }
    var cursor = action.payload.next ? action.payload.next.before : null;
    var id = action.meta.chatroomId;
    var allMessagesAreNew = areAllMessagesNew(action.payload.items);
    var currCursor = (state[id] || {}).cursor;
    var hasCursor = currCursor !== null && currCursor !== undefined;
    return allMessagesAreNew || !hasCursor ? updateCursorAndResetError(state, cursor, id) : resetError(state, id);
}
function fetchMoreRoomMessagesSuccess(state, action) {
    var cursor = action.payload.next ? action.payload.next.before : null;
    var id = action.meta.chatroomId;
    return updateCursorAndResetError(state, cursor, id);
}
var updateCursorAndResetError = function (state, cursor, id) {
    var _a;
    return (__assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, (state[id] || {})), { cursor: cursor, error: undefined }), _a)));
};
var resetError = function (state, id) {
    var _a;
    return (__assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, state[id]), { error: undefined }), _a)));
};
var mergeTypingEventIntoTypingStatus = function (currentTypingStatus, typingEvent) {
    if (typingEvent.type === EVENT_TYPES.TYPING_STARTED) {
        return addTypingEventToTypingStatuses(currentTypingStatus, typingEvent);
    }
    else {
        return removeUserFromTypingStatuses(currentTypingStatus, typingEvent);
    }
};
var removeUserFromTypingStatuses = function (typingStatuses, typingEvent) {
    return !_isEmpty(typingStatuses)
        ? typingStatuses.filter(function (_a) {
            var userId = _a.userId;
            return userId !== typingEvent.userId;
        })
        : EmptyTypingStatus;
};
var addTypingEventToTypingStatuses = function (typingStatuses, typingEvent) {
    var result;
    if (!typingEvent.isCurrentUser && !isUserIdAlreadyTyping(typingStatuses, typingEvent)) {
        result = __spreadArrays(typingStatuses);
        result.push({
            userId: typingEvent.userId,
            displayData: typingEvent.displayData,
        });
    }
    else {
        result = typingStatuses;
    }
    return result;
};
var isUserIdAlreadyTyping = function (typingStatuses, typingEvent) {
    return typingStatuses.some(function (_a) {
        var userId = _a.userId;
        return userId === typingEvent.userId;
    });
};
function setRoomRead(state, chatroomId) {
    var _a;
    var lastReadMessageSequence = (_a = state[chatroomId].lastMessage) === null || _a === void 0 ? void 0 : _a.sequence;
    return mergeRoom(state, {
        unreadCount: 0,
        id: chatroomId,
        lastReadMessageSequence: lastReadMessageSequence,
    });
}
function setRoomSeen(state, chatroomId) {
    var lastSeenMessageSequence = _get(state[chatroomId], 'lastMessage.sequence');
    return mergeRoom(state, {
        id: chatroomId,
        lastSeenMessageSequence: lastSeenMessageSequence,
    });
}
function archiveRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function (chatroomId) { return (updatedState = archiveRoom(updatedState, chatroomId)); });
    return updatedState;
}
function unarchiveRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function (chatroomId) { return (updatedState = unarchiveRoom(updatedState, chatroomId)); });
    return updatedState;
}
function deleteRoom(state, chatroomId) {
    return __assign({}, _omit(state, chatroomId));
}
function deleteRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function (chatroomId) { return (updatedState = deleteRoom(updatedState, chatroomId)); });
    return updatedState;
}
function shouldDropClusteredAction(action) {
    var _a;
    var isFetchingFromServer = !_get(action, 'meta.fromStorage', false);
    if ((_a = action === null || action === void 0 ? void 0 : action.meta) === null || _a === void 0 ? void 0 : _a.actionClusterId) {
        if (isFetchingFromServer) {
            processedClusterActions[action.meta.actionClusterId] = true;
        }
        else if (processedClusterActions[action.meta.actionClusterId]) {
            delete processedClusterActions[action.meta.actionClusterId];
            return true;
        }
    }
    return false;
}
function byId(state, action) {
    var _a, _b, _c;
    if (state === void 0) { state = initialState; }
    var id;
    switch (action.type) {
        case types.TYPING_STATUS_CHANGE:
            return mergeRoom(state, { id: action.payload.chatroomId }, [], { typingEvent: action.payload });
        case success(types.FETCH_ROOM):
            if (isStaleRoomLastMessage(action.payload, state)) {
                return state;
            }
            return mergeRoom(state, action.payload);
        case success(types.FETCH_ENRICHED_ROOM):
            if (isStaleRoomLastMessage(action.payload.chatroom, state)) {
                return state;
            }
            return mergeRoom(state, action.payload.chatroom, action.payload.participants.items, {
                enrichedChatroomLoaded: true,
            });
        case types.UPDATE_ROOM_LABELS:
            return mergeLabelsToChatrooms(state, action.payload.chatroomParticipantLabel);
        case pending(types.UPDATE_ROOM_LABEL):
            return mergeLabelsToChatrooms(state, [action.meta.updateLabel]);
        case types.REMOVE_ROOM_LABELS:
            return mergeLabelsToChatrooms(state, action.payload, true);
        case success(types.FETCH_ROOMS):
            if (shouldDropClusteredAction(action)) {
                return state;
            }
            return fetchRooms(state, action, true);
        case types.ADD_ROOMS:
            return addRooms(state, action.rooms);
        case pending(types.SEND_MESSAGE): {
            var sentMessage = action.meta.message;
            return updateLastMessage(state, sentMessage);
        }
        case types.ADD_MESSAGE:
            return addMessage(state, action);
        case types.HANDLE_ROOM_ARCHIVED:
        case pending(types.ARCHIVE_ROOM):
            return archiveRoom(state, action.meta.chatroomId);
        case success(types.ARCHIVE_ROOMS):
            return archiveRooms(state, action);
        case success(types.UNARCHIVE_ROOMS):
            return unarchiveRooms(state, action);
        case success(types.DELETE_ROOMS):
            return deleteRooms(state, action);
        case types.HANDLE_ROOM_UNARCHIVED:
        case pending(types.UNARCHIVE_ROOM):
            return unarchiveRoom(state, action.meta.chatroomId);
        case pending(types.DELETE_ROOM):
        case types.REMOVE_ROOM:
            return deleteRoom(state, action.meta.chatroomId);
        case types.SET_MESSAGES_READ_FOR_SELF:
        case pending(types.SET_MESSAGES_READ): {
            var _d = action.meta, lastReadMessageSequence = _d.lastReadMessageSequence, chatroomId = _d.chatroomId;
            return mergeRoom(state, { unreadCount: 0, lastReadMessageSequence: lastReadMessageSequence, id: chatroomId });
        }
        case pending(types.SET_ROOMS_MESSAGES_READ): {
            var updatedState_1 = __assign({}, state);
            var chatroomIds = action.meta.chatroomIds;
            chatroomIds.forEach(function (chatroomId) {
                updatedState_1 = setRoomRead(updatedState_1, chatroomId);
            });
            return updatedState_1;
        }
        case pending(types.SET_LAST_MESSAGE_UNREAD): {
            var _e = action.meta, lastReadMessageSequence = _e.lastReadMessageSequence, chatroomId = _e.chatroomId;
            return mergeRoom(state, { unreadCount: 1, lastReadMessageSequence: lastReadMessageSequence, id: chatroomId }, [], {
                overrideRegardlessOfSequenceComparison: true,
            });
        }
        case success(types.FETCH_ROOM_MESSAGES):
            return action.meta.isFetchMore
                ? fetchMoreRoomMessagesSuccess(state, action)
                : fetchRoomMessagesSuccess(state, action);
        case error(types.FETCH_ROOM_MESSAGES):
            if (!action.payload.is401Error) {
                //skip ChatSdkErrors that are 401 errors, they shouldn't be shown to users
                id = action.meta.chatroomId;
                var newState = __assign(__assign({}, state), (_a = {}, _a[id] = __assign(__assign({}, state[id]), { error: action.payload }), _a));
                return newState;
            }
            else {
                return state;
            }
        case error(types.SEND_MESSAGE):
            id = action.meta.message.chatroomId;
            return __assign(__assign({}, state), (_b = {}, _b[id] = __assign(__assign({}, state[id]), { messageDeliveryError: true }), _b));
        case success(types.SEND_MESSAGE):
            id = action.meta.message.chatroomId;
            return __assign(__assign({}, state), (_c = {}, _c[id] = __assign(__assign({}, state[id]), { messageDeliveryError: undefined }), _c));
        case success(types.SET_UNSEEN_CHATROOMS): {
            var unseenChatrooms = action.payload;
            return unseenChatrooms.reduce(function (prev, _a) {
                var chatroomId = _a.chatroomId, lastSeenMessageSequence = _a.lastSeenMessageSequence;
                var chatroom = state[chatroomId];
                if (!chatroom) {
                    return prev;
                }
                return mergeRoom(prev, {
                    id: chatroomId,
                    lastSeenMessageSequence: Math.max(lastSeenMessageSequence, chatroom.lastSeenMessageSequence || default_lastSeenMessageSequence),
                });
            }, state);
        }
        case pending(types.MARK_CHATROOMS_SEEN): {
            var filteredChatrooms = action.meta.filteredChatrooms;
            return filteredChatrooms.reduce(function (prev, chatroom) { return setRoomSeen(prev, chatroom.id); }, state);
        }
        default:
            return state;
    }
}
var statusInitialState = {
    isFetchingRooms: false,
    isFetchingFromStorage: false,
    isFetchingMoreRooms: false,
    isFetchingRoom: false,
};
function status(state, action) {
    if (state === void 0) { state = statusInitialState; }
    var isFetchingFromStorage = _get(action, 'meta.fromStorage', false);
    switch (action.type) {
        case success(types.FETCH_ROOM):
        case error(types.FETCH_ROOM):
            return __assign(__assign({}, state), { isFetchingRoom: false });
        case pending(types.FETCH_ROOM):
            return __assign(__assign({}, state), { isFetchingRoom: true });
        case success(types.FETCH_ROOMS):
            if (isFetchingFromStorage) {
                return __assign(__assign({}, state), { isFetchingFromStorage: false });
            }
            return __assign(__assign({}, state), { isFetchingRooms: false, isFetchingMoreRooms: false, error: null });
        case error(types.FETCH_ROOMS): {
            var errorPayload = action.payload.is401Error ? null : action.payload;
            return __assign(__assign({}, state), { isFetchingRooms: false, isFetchingMoreRooms: false, error: errorPayload, isFetchingFromStorage: isFetchingFromStorage });
        }
        case pending(types.FETCH_ROOMS): {
            if (isFetchingFromStorage) {
                return __assign(__assign({}, state), { isFetchingFromStorage: true });
            }
            var isSilent = _get(action, 'meta.isSilent');
            var isFetchingMoreRooms = _get(action, 'meta.isFetchMore') && !isSilent;
            if (isFetchingFromStorage) {
                return __assign(__assign({}, state), { isFetchingFromStorage: !isSilent, isFetchingMoreRooms: isFetchingMoreRooms, error: null });
            }
            return __assign(__assign({}, state), { isFetchingRooms: !isSilent, isFetchingMoreRooms: isFetchingMoreRooms, error: null });
        }
        default:
            return state;
    }
}
function filter(state, action) {
    var _a, _b;
    var _c;
    if (state === void 0) { state = initialFiltersBySubscriberIdState; }
    switch (action.type) {
        case types.SET_CURRENT_FILTER: {
            var _d = action.meta, filter_1 = _d.filter, subscriberId = _d.subscriberId;
            return __assign(__assign({}, state), (_a = {}, _a[subscriberId] = __assign(__assign({}, (state[subscriberId] || {})), { currentFilter: filter_1 ? __assign({}, filter_1) : {} }), _a));
        }
        case types.SET_UNREAD_FILTERED_ROOMS_IDS: {
            var _e = action.meta, shouldOverride = _e.shouldOverride, unreadFilteredRoomsIds = _e.unreadFilteredRoomsIds, subscriberId = _e.subscriberId;
            var currentUnreadFilteredRoomsIds = ((_c = state[subscriberId]) === null || _c === void 0 ? void 0 : _c.unreadFilteredRoomsIds) || [];
            var updatedUnreadFilteredRoomsIds = shouldOverride
                ? __spreadArrays(unreadFilteredRoomsIds) : __spreadArrays(currentUnreadFilteredRoomsIds, unreadFilteredRoomsIds);
            return __assign(__assign({}, state), (_b = {}, _b[subscriberId] = __assign(__assign({}, (state[subscriberId] || {})), { unreadFilteredRoomsIds: updatedUnreadFilteredRoomsIds }), _b));
        }
        default:
            return state;
    }
}
var chatroomsReducer = combineReducers({ status: status, byId: byId, filter: filter });
export { chatroomsReducer, byId, status };
