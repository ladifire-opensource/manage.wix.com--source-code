import { __assign } from "tslib";
import types from '../types';
import { MessageSendStatus } from '../../constants/constants';
import _isEmpty from 'lodash/isEmpty';
import _omit from 'lodash/omit';
import { success, pending, error, toStateObj } from '../../utils/utils.index';
import { combineReducers } from 'redux';
import * as Constants from '../../constants/constants';
import { areAllMessagesNew } from '../helpers/messages.helper';
var initialState = {};
function byId(state, action) {
    if (state === void 0) { state = initialState; }
    switch (action.type) {
        case success(types.FETCH_ROOM_MESSAGES):
            return handleFetchRoomMessages(state, action, action.meta.isFetchMore);
        case types.ADD_MESSAGE:
            return handleAddMessage(state, action.message);
        case success(types.SEND_MESSAGE):
            return handleSentMessage(state, action.meta.message);
        case pending(types.SEND_MESSAGE):
            return handleSendingMessage(state, action.meta.message);
        case error(types.SEND_MESSAGE):
            return handleSendMessageError(state, action.meta.message, action.payload);
        case types.RESEND_MESSAGE:
            return handleResendMessage(state, action.meta.messageId);
        case types.DELETE_MESSAGE:
            return handleDeleteMessage(state, action.meta.messageId);
        case success(types.DELETE_ROOM):
            return removeChatroomMessages(state, action.meta.chatroomId);
        case success(types.DELETE_ROOMS):
            return deleteRooms(state, action);
        case success(types.FETCH_ROOMS):
            return handleFetchRoomSuccess(state, action.payload);
        default:
            return state;
    }
}
var handleFetchRoomMessages = function (state, action, isFetchMore) {
    if (_isEmpty(action.payload)) {
        // this can happen when cache is empty or if we got en error while fetching from cache
        return state;
    }
    var messages = action.payload.items;
    var shouldResetTransit = !action.meta.fromStorage;
    var overrides = shouldResetTransit ? { transit: { sendStatus: MessageSendStatus.SENT } } : {};
    var fetchedMessages = toStateObj(messages, 'id', overrides);
    var shouldDiscardOldMessagesInRoom = !isFetchMore && !!Object.keys(fetchedMessages).length && areAllMessagesNew(messages);
    return __assign(__assign({}, existingMessages(state, action.meta.chatroomId, shouldDiscardOldMessagesInRoom)), fetchedMessages);
};
var existingMessages = function (state, chatroomId, shouldDiscardOldMessagesInRoom) {
    return shouldDiscardOldMessagesInRoom ? allMessagesExceptChatroom(state, chatroomId) : state;
};
var allMessagesExceptChatroom = function (state, chatroomId) {
    return Object.values(state).reduce(function (acc, message) {
        if (message.chatroomId !== chatroomId) {
            acc[message.id] = message;
        }
        return acc;
    }, []);
};
var handleAddMessage = function (state, item) {
    return mergeNewItem(state, item);
};
var handleSentMessage = function (state, item) {
    var newTransit = { sendStatus: Constants.MessageSendStatus.SENT };
    var transit = _omit(mergeTransits(state, item, newTransit), ['sendError']);
    return mergeNewItem(state, item, { transit: transit });
};
var handleSendingMessage = function (state, item) {
    var newTransit = { sendStatus: Constants.MessageSendStatus.SENDING };
    var transit = _omit(mergeTransits(state, item, newTransit), ['sendError']);
    return mergeNewItem(state, item, { transit: transit });
};
var handleSendMessageError = function (state, item, sdkError) {
    var newTransit = {
        sendStatus: Constants.MessageSendStatus.FAILED,
        sendError: sdkError,
    };
    var transit = mergeTransits(state, item, newTransit);
    return mergeNewItem(state, item, { transit: transit });
};
var mergeTransits = function (state, item, newTransit) {
    var itemTransit = item ? item.transit : {};
    var previousStateTransit = item && state[item.id] ? state[item.id].transit : {};
    return __assign(__assign(__assign({}, previousStateTransit), itemTransit), newTransit);
};
var sequenceValueToOverride = function (currentSequence, newSequence) {
    return !newSequence && !!currentSequence ? currentSequence : newSequence;
};
var mergeNewItem = function (state, item, overrides) {
    if (overrides === void 0) { overrides = {}; }
    var newState = __assign({}, state);
    var existingItem = newState[item.id] || {};
    newState[item.id] = __assign(__assign(__assign(__assign({}, existingItem), item), { sequence: sequenceValueToOverride(existingItem.sequence, item.sequence) }), overrides);
    return newState;
};
var handleDeleteMessage = function (state, messageId) {
    var newState = __assign({}, state);
    delete newState[messageId];
    return newState;
};
var handleResendMessage = function (state, messageId) {
    return handleDeleteMessage(state, messageId);
};
var handleFetchRoomSuccess = function (state, payload) {
    if (!payload) {
        return state;
    }
    var items = payload.chatrooms.items;
    var newMessages = items.reduce(function (acc, room) {
        return Object.assign(acc, toStateObj(room.lastMessages || [], 'id', { transit: { sendStatus: MessageSendStatus.SENT } }));
    }, {});
    return __assign(__assign({}, state), newMessages);
};
function removeChatroomMessages(messages, chatroomId) {
    var result = {};
    Object.keys(messages).forEach(function (messageId) {
        if (messages[messageId].chatroomId !== chatroomId) {
            result[messageId] = messages[messageId];
        }
    });
    return result;
}
function deleteRooms(state, action) {
    var updatedState = __assign({}, state);
    var chatroomIds = action.meta.chatroomIds;
    chatroomIds.forEach(function (chatroomId) {
        updatedState = removeChatroomMessages(updatedState, chatroomId);
    });
    return updatedState;
}
var messagesReducer = combineReducers({ byId: byId });
export { byId, messagesReducer };
