import { __assign } from "tslib";
import types from '../types';
import { success } from '../../utils/promise-middleware-utils';
import { combineReducers } from 'redux';
import _isEmpty from 'lodash/isEmpty';
import _reduce from 'lodash/reduce';
import _merge from 'lodash/merge';
import _first from 'lodash/first';
var initialState = {};
var mergeEnrichedRoomMessageIndications = function (state, indications, lastMessageId) {
    var _a;
    if (!lastMessageId) {
        return state;
    }
    var enrichedIndicationsDelta = getEnrichedIndicationsDelta(indications.lastMessageIndications, state, lastMessageId);
    if (_isEmpty(enrichedIndicationsDelta)) {
        return state;
    }
    return __assign(__assign({}, state), (_a = {}, _a[lastMessageId] = _merge({}, state[lastMessageId], enrichedIndicationsDelta), _a));
};
var mergeDrillInMessageIndications = function (state, drillInIndicationsDto) {
    var _a;
    var messageId = drillInIndicationsDto.messageId;
    var drillInIndicationsDelta = getDrillInIndicationsDelta(drillInIndicationsDto.indications, state, messageId);
    if (_isEmpty(drillInIndicationsDelta)) {
        return state;
    }
    return __assign(__assign({}, state), (_a = {}, _a[messageId] = _merge({}, state[messageId], drillInIndicationsDelta), _a));
};
var mergeRealtimeMessagesIndicationsEvent = function (state, payload) {
    var realtimeIndicationsDelta = getRealtimeIndicationsDelta(payload.messageIds, payload.participantId, payload.indication, state);
    if (_isEmpty(realtimeIndicationsDelta)) {
        return state;
    }
    return _merge({}, state, realtimeIndicationsDelta);
};
var getLastMessageId = function (chatroom) { var _a; return (_a = _first(chatroom === null || chatroom === void 0 ? void 0 : chatroom.lastMessages)) === null || _a === void 0 ? void 0 : _a.id; };
var byId = function (state, action) {
    if (state === void 0) { state = initialState; }
    switch (action.type) {
        case success(types.FETCH_MESSAGES_ERRORS_INDICATIONS):
            return handleFetchMessagesErrorIndications(state, action);
        case success(types.FETCH_ENRICHED_ROOM):
            return !_isEmpty(action.payload.indications.lastMessageIndications)
                ? mergeEnrichedRoomMessageIndications(state, action.payload.indications, getLastMessageId(action.payload.chatroom))
                : state;
        case success(types.FETCH_DRILL_IN_MESSAGE_INDICATIONS):
            return !_isEmpty(action.payload.indications) ? mergeDrillInMessageIndications(state, action.payload) : state;
        case types.UPDATE_MESSAGES_INDICATIONS:
            return !_isEmpty(action.payload.messageIds)
                ? mergeRealtimeMessagesIndicationsEvent(state, action.payload)
                : state;
        default:
            return state;
    }
};
var handleFetchMessagesErrorIndications = function (state, action) {
    if (_isEmpty(action.payload)) {
        // this can happen when cache is empty or if we got en error while fetching from cache
        return state;
    }
    var errorIndications = action.payload;
    var newIndicationState = errorIndications.indications.reduce(function (newState, indication) {
        var _a;
        var messageIndicationsByParticipant = indication.indications.reduce(function (acc, v) {
            var _a, _b;
            var indicationDetails = v.indication;
            return __assign(__assign({}, acc), (_a = {}, _a[v.participantId] = __assign(__assign({}, (acc[v.participantId] || {})), (_b = {}, _b[getIndicationHashFromDetails(indicationDetails)] = __assign({}, indicationDetails), _b)), _a));
        }, {});
        return _isEmpty(messageIndicationsByParticipant)
            ? newState
            : __assign(__assign({}, newState), (_a = {}, _a[indication.messageId] = __assign(__assign({}, (newState[indication.messageId] || {})), messageIndicationsByParticipant), _a));
    }, {});
    return __assign(__assign({}, state), newIndicationState);
};
var getDrillInIndicationsDetailsDelta = function (participantIndicationsData, state, messageId) {
    return _reduce(participantIndicationsData.indications, function (detailsAcc, details) {
        var _a;
        var participantIndicationsDetailsFromState = state[messageId]
            ? state[messageId][participantIndicationsData.participantId]
            : {};
        if (isIndicationDetailsAlreadyExists(details, participantIndicationsDetailsFromState)) {
            return detailsAcc;
        }
        return __assign(__assign({}, detailsAcc), (_a = {}, _a[getIndicationHashFromDetails(details)] = details, _a));
    }, {});
};
var getDrillInIndicationsDelta = function (participantsIndications, state, messageId) {
    return _reduce(participantsIndications, function (participantsIndicationsAcc, singleParticipantIndications) {
        var _a;
        var drillInIndicationsDetailsDelta = getDrillInIndicationsDetailsDelta(singleParticipantIndications, state, messageId);
        if (_isEmpty(drillInIndicationsDetailsDelta)) {
            return participantsIndicationsAcc;
        }
        return _merge({}, participantsIndicationsAcc, (_a = {},
            _a[singleParticipantIndications.participantId] = drillInIndicationsDetailsDelta,
            _a));
    }, {});
};
var getEnrichedIndicationsDetailsDelta = function (participantIndicationsData, state, messageId) {
    var _a;
    var participantIndicationsDetailsFromState = state[messageId]
        ? state[messageId][participantIndicationsData.participantId]
        : {};
    var details = participantIndicationsData.indication;
    if (isIndicationDetailsAlreadyExists(details, participantIndicationsDetailsFromState)) {
        return {};
    }
    return _a = {}, _a[getIndicationHashFromDetails(details)] = details, _a;
};
var getEnrichedIndicationsDelta = function (participantsIndications, state, messageId) {
    return _reduce(participantsIndications, function (participantsIndicationsAcc, singleParticipantIndications) {
        var _a;
        var enrichedIndicationsDetailsDelta = getEnrichedIndicationsDetailsDelta(singleParticipantIndications, state, messageId);
        if (_isEmpty(enrichedIndicationsDetailsDelta)) {
            return participantsIndicationsAcc;
        }
        return _merge({}, participantsIndicationsAcc, (_a = {},
            _a[singleParticipantIndications.participantId] = enrichedIndicationsDetailsDelta,
            _a));
    }, {});
};
var getRealtimeIndicationsDelta = function (messageIds, participantId, indicationDetails, state) {
    return _reduce(messageIds, function (messagesIndicationsAcc, messageId) {
        var _a, _b, _c;
        var participantIndicationsDetailsFromState = state[messageId] ? state[messageId][participantId] : {};
        if (isIndicationDetailsAlreadyExists(indicationDetails, participantIndicationsDetailsFromState)) {
            return {};
        }
        return _merge({}, messagesIndicationsAcc, (_a = {},
            _a[messageId] = __assign(__assign({}, state[messageId]), (_b = {}, _b[participantId] = (_c = {}, _c[getIndicationHashFromDetails(indicationDetails)] = indicationDetails, _c), _b)),
            _a));
    }, {});
};
var isIndicationDetailsAlreadyExists = function (indicationDetails, participantIndicationsDetailsFromState) {
    // TODO: Should be fully handled for Group Chat indication handling
    return (participantIndicationsDetailsFromState !== undefined &&
        !!participantIndicationsDetailsFromState[getIndicationHashFromDetails(indicationDetails)]);
};
export var getIndicationHashFromDetails = function (indicationDetails) {
    return indicationDetails.event + "-" + indicationDetails.method + "-" + (indicationDetails.code || '000');
};
export var messagesIndicationsReducer = combineReducers({ byId: byId });
