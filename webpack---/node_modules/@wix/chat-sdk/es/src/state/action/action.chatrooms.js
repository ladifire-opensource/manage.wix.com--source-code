import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
import types from '../types';
import * as chatEventEmitter from '../../services/chat-event-emitter.service';
import { FetchChatroomsPageSizeDefaultValue, FetchRoomMessagesPageSize, experiments as experimentsConstants, } from '../../constants/constants';
import { getLastReadMessageSequence } from '../reducer/selector.chatrooms';
import { createSortedMessagesSelector, sortMessagesBySequence } from '../reducer/selector.messages';
import { getExperimentValue, isExperimentOn } from '../../utils/experiments-utils';
import { CHAT_EVENTS } from '../../services/chat-event-emitter.service';
import MasterPageManager from '../../services/master-page-manager';
import { pending } from '../../utils/utils.index';
import { EVENTS } from '../../constants/bi-logger.config';
import appService from '../../services/app-service';
import uuidV4 from 'uuid/v4';
import _first from 'lodash/first';
import _last from 'lodash/last';
var ChatRoomsActions = /** @class */ (function () {
    function ChatRoomsActions(serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments, dbStorageService) {
        this.serverApi = serverApi;
        this.persistence = persistenceService;
        this.dbStorageService = dbStorageService;
        this.eventHooks = eventHooks;
        this.unseenChatroomCountActions = unseenChatroomCountActions;
        this.unreadChatroomCountActions = unreadChatroomCountActions;
        this.experiments = experiments;
    }
    ChatRoomsActions.prototype.action$resetStore = function () {
        return {
            type: types.RESET_STORE,
        };
    };
    ChatRoomsActions.prototype.fetchRoomMessages = function (chatroomId, cursor) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            var fetchParams, serverPromise, e_1, action;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fetchParams = { chatroomId: chatroomId, cursor: cursor, pageSize: FetchRoomMessagesPageSize };
                        serverPromise = this.serverApi.http$fetchRoomMessages(fetchParams);
                        if (!this.dbStorageService) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, dispatch(this.loadMessagesFromStorage(fetchParams))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.warn('Unable to load room messages from storage', e_1);
                        return [3 /*break*/, 4];
                    case 4:
                        action = {
                            type: types.FETCH_ROOM_MESSAGES,
                            payload: serverPromise,
                            meta: {
                                chatroomId: chatroomId,
                                isFetchMore: !!cursor,
                            },
                        };
                        return [4 /*yield*/, dispatch(action)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.fetchMessageErrorIndications = function (chatroomId) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var state, messages, from, to, serverPromise, action;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!isExperimentOn(this.experiments, experimentsConstants.InboxErrorIndications)) {
                            return [2 /*return*/, null];
                        }
                        state = getState();
                        messages = createSortedMessagesSelector(chatroomId, sortMessagesBySequence)(state);
                        if (!messages || !messages.length) {
                            return [2 /*return*/, null];
                        }
                        from = _first(messages).sequence;
                        to = _last(messages).sequence;
                        serverPromise = this.serverApi.http$fetchMessagesErrorIndications({ chatroomId: chatroomId, from: from, to: to });
                        action = {
                            type: types.FETCH_MESSAGES_ERRORS_INDICATIONS,
                            payload: serverPromise,
                            meta: {
                                chatroomId: chatroomId,
                            },
                        };
                        return [4 /*yield*/, dispatch(action)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$fetchRoom = function (chatroomId, enrichedChatroom, force) {
        if (enrichedChatroom === void 0) { enrichedChatroom = false; }
        if (force === void 0) { force = false; }
        if (!chatroomId) {
            //this is hopefully temporary code, we need to hunt down the source
            //of these errors: https://rpm.newrelic.com/accounts/23428/applications/37820036/traced_errors/bb98a11d-205a-11e8-ba9c-0242ac110006_10172_23269
            //we can look in user explorer to see what users did before they got this error
            //to try to figure out causes someone to try to fetch an undefined chatroom
            //if the quantity of these BI events don't match the NR errors, then
            //there's a chat-sdk client that isn't supplying a proper reportMonitoringBi
            //function.
            var event = {
                tag: 'error',
                description: "Attempting to fetch chatroom with undefined chatroomId.",
            };
            chatEventEmitter.emit(CHAT_EVENTS.MONITORING_BI, event);
            this.eventHooks.reportMonitoringBi(event);
            // TODO: remove when error is resolved: https://sentry.io/wix_o/wix-one-app/issues/718628954/events/36573747091/
            console.error('[Troubleshoot] called fetchRoom w/o chatroomId', new Error());
        }
        return enrichedChatroom
            ? {
                type: types.FETCH_ENRICHED_ROOM,
                payload: this.serverApi.http$fetchEnrichedChatroom({ chatroomId: chatroomId, force: force }).then(function (enrichedRoom) {
                    chatEventEmitter.emit(chatEventEmitter.CHAT_INTERNAL_EVENTS.FETCH_ENRICHED_CHATROOM_COMPLETED, enrichedRoom);
                    return enrichedRoom;
                }),
            }
            : {
                type: types.FETCH_ROOM,
                payload: this.serverApi.http$fetchRoom({ chatroomId: chatroomId }),
            };
    };
    ChatRoomsActions.prototype.action$deleteRoom = function (chatroomId) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decrementCounters(dispatch, chatroomId)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, dispatch({
                                type: types.DELETE_ROOM,
                                payload: this.serverApi.http$deleteChatroom({ chatroomId: chatroomId }),
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$removeRoom = function (chatroomId) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decrementCounters(dispatch, chatroomId)];
                    case 1:
                        _a.sent();
                        MasterPageManager.removeRoom(chatroomId);
                        return [2 /*return*/, dispatch({
                                type: types.REMOVE_ROOM,
                                meta: {
                                    chatroomId: chatroomId,
                                },
                            })];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$updateRoomLabels = function (payload) {
        return {
            type: types.UPDATE_ROOM_LABELS,
            payload: payload,
        };
    };
    ChatRoomsActions.prototype.action$updateRoomLabel = function (updateLabel) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, dispatch({
                        type: types.UPDATE_ROOM_LABEL,
                        payload: this.serverApi.http$updateLabel(updateLabel),
                        meta: {
                            updateLabel: updateLabel,
                        },
                    })];
            });
        }); };
    };
    ChatRoomsActions.prototype.action$removeRoomLabels = function (payload, persist) {
        var _this = this;
        if (persist === void 0) { persist = false; }
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (persist) {
                    payload.map(function (_a) {
                        var _b;
                        var chatroomId = _a.chatroomId, labelId = _a.labelId;
                        var chatroom = getState().chatrooms.byId[chatroomId];
                        return ((_b = chatroom === null || chatroom === void 0 ? void 0 : chatroom.labelIds) === null || _b === void 0 ? void 0 : _b.includes(labelId)) ? _this.serverApi.http$deleteLabel({ chatroomId: chatroomId, labelId: labelId })
                            : Promise.resolve();
                    });
                }
                dispatch({
                    type: types.REMOVE_ROOM_LABELS,
                    payload: payload,
                });
                return [2 /*return*/];
            });
        }); };
    };
    ChatRoomsActions.prototype.action$handleRoomArchived = function (chatroomId) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decrementCounters(dispatch, chatroomId)];
                    case 1:
                        _a.sent();
                        dispatch({
                            type: types.HANDLE_ROOM_ARCHIVED,
                            meta: {
                                chatroomId: chatroomId,
                            },
                        });
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$handleRoomUnarchived = function (chatroomId) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                dispatch({
                    type: types.HANDLE_ROOM_UNARCHIVED,
                    meta: {
                        chatroomId: chatroomId,
                        chatroom: getState().chatrooms.byId[chatroomId],
                    },
                });
                return [2 /*return*/];
            });
        }); };
    };
    ChatRoomsActions.prototype.archiveRoom = function (chatroomId) {
        var _this = this;
        return function (dispatch) {
            return Promise.all([
                _this.decrementCounters(dispatch, chatroomId),
                dispatch({
                    type: types.ARCHIVE_ROOM,
                    payload: _this.serverApi.http$archiveChatroom({ chatroomId: chatroomId }),
                    meta: {
                        chatroomId: chatroomId,
                    },
                }),
            ]);
        };
    };
    ChatRoomsActions.prototype.unarchiveRoom = function (chatroomId) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, dispatch({
                            type: types.UNARCHIVE_ROOM,
                            payload: this.serverApi.http$unarchiveChatroom({ chatroomId: chatroomId }),
                            meta: {
                                chatroomId: chatroomId,
                                chatroom: getState().chatrooms.byId[chatroomId],
                            },
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.loadMessagesFromStorage = function (fetchParams) {
        var _a;
        return {
            type: types.FETCH_ROOM_MESSAGES,
            payload: (_a = this.dbStorageService) === null || _a === void 0 ? void 0 : _a.loadMessages(fetchParams),
            meta: __assign({ fromStorage: true }, fetchParams),
        };
    };
    ChatRoomsActions.prototype.loadRoomsFromStorage = function (fetchParams, actionClusterId) {
        var _a;
        return {
            type: types.FETCH_ROOMS,
            payload: (_a = this.dbStorageService) === null || _a === void 0 ? void 0 : _a.loadChatrooms(fetchParams),
            meta: __assign(__assign({ fromStorage: true }, fetchParams), { actionClusterId: actionClusterId }),
        };
    };
    ChatRoomsActions.prototype.fetchRooms = function (_a) {
        var _this = this;
        var _b = _a === void 0 ? { filter: {}, cursor: undefined, isSilent: false } : _a, filter = _b.filter, cursor = _b.cursor, _c = _b.isSilent, isSilent = _c === void 0 ? false : _c;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            var pageSize, fetchParams, serverPromise, actionClusterId, serverAction, pendingServerAction;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pageSize = this.getPageSize(this.experiments, experimentsConstants.FetchChatroomsPageSize, FetchChatroomsPageSizeDefaultValue);
                        fetchParams = { nextPointer: cursor, filter: filter, pageSize: pageSize };
                        serverPromise = this.serverApi.http$fetchChatrooms(fetchParams);
                        actionClusterId = uuidV4();
                        serverAction = {
                            type: types.FETCH_ROOMS,
                            payload: serverPromise,
                            meta: {
                                filter: filter,
                                isSilent: isSilent,
                                isFetchMore: !!cursor,
                                actionClusterId: actionClusterId,
                            },
                        };
                        pendingServerAction = {
                            type: pending(serverAction.type),
                            meta: serverAction.meta,
                        };
                        if (this.dbStorageService) {
                            try {
                                dispatch(pendingServerAction);
                                dispatch(this.loadRoomsFromStorage(fetchParams, actionClusterId));
                            }
                            catch (e) {
                                console.warn('Unable to load rooms from storage', e);
                            }
                        }
                        return [4 /*yield*/, dispatch(serverAction)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.addRooms = function (rooms) {
        return {
            type: types.ADD_ROOMS,
            rooms: rooms,
        };
    };
    ChatRoomsActions.prototype.action$addMessage = function (message, messageSentByCurrentUser, chatroom) {
        return function (dispatch) {
            dispatch({
                type: types.ADD_MESSAGE,
                message: message,
                messageSentByCurrentUser: messageSentByCurrentUser,
                meta: {
                    chatroom: chatroom,
                },
            });
        };
    };
    ChatRoomsActions.prototype.action$sendMessage = function (message) {
        this.serverApi.http$notifyTyping(message.chatroomId, 'stop');
        return {
            type: types.SEND_MESSAGE,
            payload: this.serverApi.http$sendMessage(message.chatroomId, message),
            meta: {
                message: message.dto,
            },
        };
    };
    ChatRoomsActions.prototype.action$sendPostbackMessage = function (message, options) {
        message.createdAt = message.createdAt || Date.now();
        var type = message.type, sender = message.sender, id = message.id;
        chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.MESSAGE_SENT, message);
        chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.BI, __assign(__assign({}, EVENTS.sendMessage), { messageId: id, chatRoomId: message.chatroomId, messageType: type, uuid: sender === null || sender === void 0 ? void 0 : sender.userId, mimeType: message.mimeTypes, hostName: appService.appName }));
        var requestPromise = this.serverApi.http$sendMessageV2(message, options).catch(function (error) {
            chatEventEmitter.emit(chatEventEmitter.CHAT_EVENTS.BI_ERROR, {
                tag: 'send-message',
                description: 'failed to send message',
                errorName: error,
            });
            throw error;
        });
        return {
            type: types.SEND_MESSAGE,
            payload: requestPromise,
            meta: {
                message: message.dto,
            },
        };
    };
    ChatRoomsActions.prototype.action$deleteMessage = function (messageId, persist) {
        var _this = this;
        if (persist === void 0) { persist = false; }
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var message, messageSequenceToDelete, chatroomId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (persist) {
                            message = getState().messages.byId[messageId];
                            if (message) {
                                messageSequenceToDelete = message.sequence;
                                chatroomId = message.chatroomId;
                                this.serverApi.http$deleteMessage({ chatroomId: chatroomId, messageSequenceToDelete: messageSequenceToDelete });
                            }
                        }
                        return [4 /*yield*/, dispatch({
                                type: types.DELETE_MESSAGE,
                                meta: {
                                    messageId: messageId,
                                },
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$resendMessage = function (messageId) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var message, messageSequenceToReSend, chatroomId;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        message = getState().messages.byId[messageId];
                        if (message) {
                            messageSequenceToReSend = message.sequence;
                            chatroomId = message.chatroomId;
                            this.serverApi.http$resendMessage({ chatroomId: chatroomId, messageSequenceToReSend: messageSequenceToReSend });
                        }
                        return [4 /*yield*/, dispatch({
                                type: types.RESEND_MESSAGE,
                                meta: {
                                    messageId: messageId,
                                },
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$setMessagesRead = function (chatroomId, lastReadMessageSequence) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, dispatch({
                            type: types.SET_MESSAGES_READ,
                            payload: this.serverApi.http$setMessagesRead({ chatroomId: chatroomId, lastReadMessageSequence: lastReadMessageSequence }),
                            meta: {
                                chatroomId: chatroomId,
                                lastReadMessageSequence: lastReadMessageSequence,
                                chatroom: getState().chatrooms.byId[chatroomId],
                            },
                        })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.decrementUnseenCounter(dispatch, chatroomId)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$setMessagesReadForSelf = function (chatroomId, sequenceToMarkAsRead) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var lastReadMessageSequence;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        lastReadMessageSequence = getLastReadMessageSequence(getState(), chatroomId);
                        if (!(!lastReadMessageSequence || sequenceToMarkAsRead > lastReadMessageSequence)) return [3 /*break*/, 3];
                        return [4 /*yield*/, dispatch({
                                type: types.SET_MESSAGES_READ_FOR_SELF,
                                meta: {
                                    chatroomId: chatroomId,
                                    lastReadMessageSequence: sequenceToMarkAsRead,
                                },
                            })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.decrementCounters(dispatch, chatroomId)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$setRoomsMessagesRead = function (chatroomIds, mostRecentKnownMessageSequence) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(__spreadArrays([
                        dispatch({
                            type: types.SET_ROOMS_MESSAGES_READ,
                            payload: this.serverApi.http$markRoomsAsRead(chatroomIds, mostRecentKnownMessageSequence),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function (chatroomId) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.decrementUnseenCounter(dispatch, chatroomId)];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })))];
            });
        }); };
    };
    ChatRoomsActions.prototype.action$setLastMessageUnread = function (chatroomId, lastReadMessageSequence, updateServer) {
        var _this = this;
        if (updateServer === void 0) { updateServer = true; }
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, dispatch({
                            type: types.SET_LAST_MESSAGE_UNREAD,
                            payload: updateServer
                                ? this.serverApi.http$setMessagesUnread({ chatroomId: chatroomId, lastReadMessageSequence: lastReadMessageSequence })
                                : Promise.resolve(true),
                            meta: {
                                chatroomId: chatroomId,
                                lastReadMessageSequence: lastReadMessageSequence,
                                chatroom: getState().chatrooms.byId[chatroomId],
                            },
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.typing = function (chatroomId, text) {
        return {
            type: types.TYPING,
            text: text,
            meta: {
                chatroomId: chatroomId,
            },
        };
    };
    ChatRoomsActions.prototype.fetchMessageDrafts = function () {
        return {
            type: types.FETCH_MESSAGE_DRAFTS,
            payload: this.persistence.loadMessageDrafts(),
        };
    };
    ChatRoomsActions.prototype.action$changeTypingStatus = function (payload) {
        return {
            type: types.TYPING_STATUS_CHANGE,
            payload: payload,
        };
    };
    ChatRoomsActions.prototype.action$fetchRoomParticipantsDisplayData = function (chatroomId, participantIds) {
        return {
            type: types.FETCH_PARTICIPANTS_DISPLAY_DATA,
            payload: this.serverApi.http$fetchParticipantsDisplayData({ chatroomId: chatroomId, participantIds: participantIds }),
        };
    };
    ChatRoomsActions.prototype.decrementCounters = function (dispatch, chatroomId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decrementUnseenCounter(dispatch, chatroomId)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    ChatRoomsActions.prototype.decrementUnseenCounter = function (dispatch, chatroomId) {
        dispatch(this.unreadChatroomCountActions.markChatroomAsRead(chatroomId));
        if (isExperimentOn(this.experiments, experimentsConstants.UnseenChatroomCount)) {
            return dispatch(this.unseenChatroomCountActions.markChatroomAsSeen(chatroomId));
        }
    };
    ChatRoomsActions.prototype.action$deleteRooms = function (chatroomIds) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(__spreadArrays([
                        dispatch({
                            type: types.DELETE_ROOMS,
                            payload: this.serverApi.http$deleteChatrooms(chatroomIds),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function (id) { return _this.decrementCounters(dispatch, id); })))];
            });
        }); };
    };
    ChatRoomsActions.prototype.archiveRooms = function (chatroomIds) {
        var _this = this;
        return function (dispatch) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(__spreadArrays([
                        dispatch({
                            type: types.ARCHIVE_ROOMS,
                            payload: this.serverApi.http$archiveChatrooms(chatroomIds),
                            meta: {
                                chatroomIds: chatroomIds,
                            },
                        })
                    ], chatroomIds.map(function (id) { return _this.decrementCounters(dispatch, id); })))];
            });
        }); };
    };
    ChatRoomsActions.prototype.unarchiveRooms = function (chatroomIds) {
        var _this = this;
        return function (dispatch, getState) { return __awaiter(_this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, dispatch({
                            type: types.UNARCHIVE_ROOMS,
                            payload: this.serverApi.http$unarchiveChatrooms(chatroomIds),
                            meta: {
                                chatroomIds: chatroomIds,
                                chatrooms: chatroomIds.map(function (id) { return getState().chatrooms.byId[id]; }),
                            },
                        })];
                    case 1:
                        _a.sent();
                        promises = [];
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    ChatRoomsActions.prototype.action$handleFilterChanged = function (subscriberId, filter, unreadFilteredRoomsIds) {
        var _this = this;
        return function (dispatch) {
            dispatch(_this.action$setCurrentFilter(subscriberId, filter));
            dispatch(_this.action$setUnreadFilteredRoomsIds(subscriberId, unreadFilteredRoomsIds, true));
        };
    };
    ChatRoomsActions.prototype.action$setCurrentFilter = function (subscriberId, filter) {
        return {
            type: types.SET_CURRENT_FILTER,
            meta: {
                subscriberId: subscriberId,
                filter: filter,
            },
        };
    };
    ChatRoomsActions.prototype.action$setUnreadFilteredRoomsIds = function (subscriberId, unreadFilteredRoomsIds, shouldOverride) {
        return {
            type: types.SET_UNREAD_FILTERED_ROOMS_IDS,
            meta: {
                subscriberId: subscriberId,
                unreadFilteredRoomsIds: unreadFilteredRoomsIds,
                shouldOverride: shouldOverride,
            },
        };
    };
    ChatRoomsActions.prototype.getPageSize = function (experiments, experimentName, defaultValue) {
        var result = parseInt(getExperimentValue(experiments, experimentName, defaultValue));
        return isNaN(result) ? parseInt(defaultValue) : result;
    };
    return ChatRoomsActions;
}());
export { ChatRoomsActions };
var chatroomsActionsFactory = function (serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments, dbStorageService) {
    return new ChatRoomsActions(serverApi, persistenceService, eventHooks, unseenChatroomCountActions, unreadChatroomCountActions, experiments, dbStorageService);
};
export default chatroomsActionsFactory;
