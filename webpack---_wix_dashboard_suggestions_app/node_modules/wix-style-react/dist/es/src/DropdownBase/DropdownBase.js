import _extends from "@babel/runtime/helpers/extends";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import { st, classes } from './DropdownBase.st.css';
import Popover, { placements } from '../Popover';
import DropdownLayout from '../DropdownLayout';

var DropdownBase = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(DropdownBase, _React$PureComponent);

  var _super = _createSuper(DropdownBase);

  function DropdownBase() {
    var _ref, _this$props$selectedI;

    var _this;

    _classCallCheck(this, DropdownBase);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "_dropdownLayoutRef", null);

    _defineProperty(_assertThisInitialized(_this), "_shouldCloseOnMouseLeave", false);

    _defineProperty(_assertThisInitialized(_this), "state", {
      open: _this.props.open,
      selectedId: (_ref = (_this$props$selectedI = _this.props.selectedId) !== null && _this$props$selectedI !== void 0 ? _this$props$selectedI : _this.props.initialSelectedId) !== null && _ref !== void 0 ? _ref : -1
    });

    _defineProperty(_assertThisInitialized(_this), "_isControllingOpen", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      return typeof props.open !== 'undefined';
    });

    _defineProperty(_assertThisInitialized(_this), "_isControllingSelection", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;
      return typeof props.selectedId !== 'undefined' && typeof props.onSelect !== 'undefined';
    });

    _defineProperty(_assertThisInitialized(_this), "_open", function () {
      if (!_this._isControllingOpen()) {
        _this.setState({
          open: true
        });

        _this.props.onShow();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_close", function (e) {
      if (_this._isControllingOpen()) {
        return;
      } // If called within a `mouseleave` event on the target element, we would like to close the
      // popover only on the popover's `mouseleave` event


      if (e && e.type === 'mouseleave') {
        // We're not using `setState` since we don't want to wait for the next render
        _this._shouldCloseOnMouseLeave = true;
      } else {
        _this.setState({
          open: false
        });
      }

      _this.props.onHide();
    });

    _defineProperty(_assertThisInitialized(_this), "_toggle", function () {
      !_this._isControllingOpen() && _this.setState(function (_ref2) {
        var open = _ref2.open;

        if (open) {
          _this.props.onHide();
        } else {
          _this.props.onShow();
        }

        return {
          open: !open
        };
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_handleClickOutside", function () {
      var onClickOutside = _this.props.onClickOutside;

      _this._close();

      onClickOutside && onClickOutside();
    });

    _defineProperty(_assertThisInitialized(_this), "_handlePopoverMouseEnter", function () {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter && onMouseEnter();
    });

    _defineProperty(_assertThisInitialized(_this), "_handlePopoverMouseLeave", function () {
      var onMouseLeave = _this.props.onMouseLeave;

      if (_this._shouldCloseOnMouseLeave) {
        _this._shouldCloseOnMouseLeave = false;

        _this.setState({
          open: false
        });
      }

      onMouseLeave && onMouseLeave();
    });

    _defineProperty(_assertThisInitialized(_this), "_handleSelect", function (selectedOption) {
      var newState = {};

      if (!_this._isControllingOpen()) {
        newState.open = false;
      }

      if (!_this._isControllingSelection()) {
        newState.selectedId = selectedOption.id;
      }

      _this.setState(newState, function () {
        var onSelect = _this.props.onSelect;
        onSelect && onSelect(selectedOption);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_handleClose", function () {
      if (_this.state.open) {
        _this._close();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_getSelectedOption", function (selectedId) {
      return _this.props.options.find(function (_ref3) {
        var id = _ref3.id;
        return id === selectedId;
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_isOpenKey", function (key) {
      return ['Enter', 'Spacebar', ' ', 'ArrowDown'].includes(key);
    });

    _defineProperty(_assertThisInitialized(_this), "_handleKeyDown", function (e) {
      if (_this._isControllingOpen()) {
        return;
      }

      var isHandledByDropdownLayout = _this._delegateKeyDown(e);

      if (!isHandledByDropdownLayout) {
        if (_this._isOpenKey(e.key)) {
          _this._open();

          e.preventDefault();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_delegateKeyDown", function (e) {
      if (!_this._dropdownLayoutRef) {
        return false;
      }

      return _this._dropdownLayoutRef._onKeyDown(e);
    });

    return _this;
  }

  _createClass(DropdownBase, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      // Keep internal state updated if needed
      if (this._isControllingOpen(nextProps) && this.props.open !== nextProps.open) {
        this.setState({
          open: nextProps.open
        });
      }

      if (this._isControllingSelection(nextProps) && this.props.selectedId !== nextProps.selectedId) {
        this.setState({
          selectedId: nextProps.selectedId
        });
      }
    }
  }, {
    key: "_renderChildren",
    value: function _renderChildren() {
      var children = this.props.children;
      var _this$state = this.state,
          selectedId = _this$state.selectedId,
          open = _this$state.open;

      if (!children) {
        return null;
      }

      return /*#__PURE__*/React.isValidElement(children) ? children // Returning the children as is when using in controlled mode
      : children({
        open: this._open,
        close: this._close,
        toggle: this._toggle,
        isOpen: Boolean(open),
        delegateKeyDown: this._delegateKeyDown,
        selectedOption: this._getSelectedOption(selectedId)
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          dataHook = _this$props.dataHook,
          placement = _this$props.placement,
          appendTo = _this$props.appendTo,
          showArrow = _this$props.showArrow,
          zIndex = _this$props.zIndex,
          moveBy = _this$props.moveBy,
          options = _this$props.options,
          minWidth = _this$props.minWidth,
          maxWidth = _this$props.maxWidth,
          fixed = _this$props.fixed,
          flip = _this$props.flip,
          tabIndex = _this$props.tabIndex,
          overflow = _this$props.overflow,
          dynamicWidth = _this$props.dynamicWidth,
          maxHeight = _this$props.maxHeight,
          fluid = _this$props.fluid,
          animate = _this$props.animate,
          className = _this$props.className,
          focusOnSelectedOption = _this$props.focusOnSelectedOption,
          infiniteScroll = _this$props.infiniteScroll,
          loadMore = _this$props.loadMore,
          hasMore = _this$props.hasMore,
          focusOnOption = _this$props.focusOnOption;
      var _this$state2 = this.state,
          open = _this$state2.open,
          selectedId = _this$state2.selectedId;
      return /*#__PURE__*/React.createElement(Popover, _extends({}, this.props, {
        // backward compatible for migration stylable 1 to stylable 3
        animate: animate,
        dataHook: dataHook,
        shown: open,
        placement: placement,
        dynamicWidth: dynamicWidth,
        appendTo: appendTo,
        showArrow: showArrow,
        zIndex: zIndex,
        moveBy: moveBy,
        onKeyDown: this._handleKeyDown,
        onMouseEnter: this._handlePopoverMouseEnter,
        onMouseLeave: this._handlePopoverMouseLeave,
        onClickOutside: this._handleClickOutside,
        fixed: fixed,
        flip: flip,
        fluid: fluid,
        className: st(classes.root, {
          withWidth: Boolean(minWidth || maxWidth),
          withArrow: showArrow
        }, className)
      }), /*#__PURE__*/React.createElement(Popover.Element, null, this._renderChildren()), /*#__PURE__*/React.createElement(Popover.Content, null, /*#__PURE__*/React.createElement("div", {
        style: {
          minWidth: minWidth,
          maxWidth: maxWidth
        }
      }, /*#__PURE__*/React.createElement(DropdownLayout, {
        dataHook: "dropdown-base-dropdownlayout",
        className: classes.list,
        ref: function ref(r) {
          return _this2._dropdownLayoutRef = r;
        },
        selectedId: selectedId,
        options: options,
        maxHeightPixels: maxHeight,
        onSelect: this._handleSelect,
        onClose: this._handleClose,
        tabIndex: tabIndex,
        inContainer: true,
        visible: true,
        overflow: overflow,
        focusOnSelectedOption: focusOnSelectedOption,
        infiniteScroll: infiniteScroll,
        loadMore: loadMore,
        hasMore: hasMore,
        focusOnOption: focusOnOption
      }))));
    }
  }]);

  return DropdownBase;
}(React.PureComponent);

_defineProperty(DropdownBase, "displayName", 'DropdownBase');

_defineProperty(DropdownBase, "propTypes", {
  /** Applies a data-hook HTML attribute that can be used in the tests */
  dataHook: PropTypes.string,

  /** Specifies a CSS class name to be appended to the componentâ€™s root element */
  className: PropTypes.string,

  /** Control whether the <Popover/> should be opened */
  open: PropTypes.bool,

  /** Control popover placement */
  placement: PropTypes.oneOf(placements),

  /** Specifies where popover should be inserted as a last child - whether `parent` or `window` containers */
  appendTo: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),

  /** Specifies whether popover arrow should be shown */
  showArrow: PropTypes.bool,

  /** Defines a callback function which is called when user clicks outside of a dropdown */
  onClickOutside: PropTypes.func,

  /** Defines a callback function which is called on `onMouseEnter` event on the entire component */
  onMouseEnter: PropTypes.func,

  /** Defines a callback function which is called on `onMouseLeave` event on the entire component */
  onMouseLeave: PropTypes.func,

  /** Defines a callback function which is called when dropdown is opened */
  onShow: PropTypes.func,

  /** Defines a callback function which is called when dropdown is closed */
  onHide: PropTypes.func,

  /** Defines a callback function which is called whenever user selects a different option in the list */
  onSelect: PropTypes.func,

  /**
   * Set popover's content width to a minimum width of a trigger element,
   * but it can expand up to the defined value of `maxWidth`
   */
  dynamicWidth: PropTypes.bool,

  /** Controls the minimum width of dropdown layout */
  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Controls the maximum width of dropdown layout */
  maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /** Controls the maximum height of dropdown layout */
  maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

  /**
   * Specifies a target component to be rendered. If a regular node is passed, it'll be rendered as-is.
   * If a function is passed, it's expected to return a React element.
   * The function accepts an object containing the following properties:
   *
   *  * `open` - will open the Popover
   *  * `close` - will close the Popover
   *  * `toggle` - will toggle the Popover
   *  * `isOpen` - indicates whether the items list is currently open
   *  * `delegateKeyDown` - the underlying DropdownLayout's keydown handler. It can be called
   *                        inside another keyDown event in order to delegate it.
   *  * `selectedOption` - the currently selected option
   *
   * Check inserted component documentation for more information on available properties.
   */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

  /**
   * Specifies an array of options for a dropdown list. Objects must have an id and can include string value or node.
   * If value is '-', a divider will be rendered instead (dividers do not require and id).
   */
  options: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({
    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    value: PropTypes.oneOfType([PropTypes.node, PropTypes.string, PropTypes.func]).isRequired,
    disabled: PropTypes.bool,
    overrideStyle: PropTypes.bool
  }), // A divider option without an id
  PropTypes.shape({
    value: PropTypes.oneOf(['-'])
  })])),

  /** Define the selected option in the list */
  selectedId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Handles container overflow behaviour */
  overflow: PropTypes.string,

  /** Indicates that element can be focused and where it participates in sequential keyboard navigation */
  tabIndex: PropTypes.number,

  /**
   * Sets the initially selected option in the list. Used when selection
   * behaviour is being controlled.
   */
  initialSelectedId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

  /** Specifies the stack order (`z-index`) of a dropdown layout */
  zIndex: PropTypes.number,

  /** Moves dropdown content relative to the parent on X or Y axis by a defined amount of pixels */
  moveBy: PropTypes.shape({
    x: PropTypes.number,
    y: PropTypes.number
  }),

  /**
   * Specifies whether to flip the <Popover/> placement
   * when it starts to overlap the target element (<Popover.Element/>)
   */
  flip: PropTypes.bool,

  /**
   * Specifies whether to enable the fixed behaviour. If enabled, <Popover/> keep its
   * original placement even when it's being positioned outside the boundary.
   */
  fixed: PropTypes.bool,

  /** Stretches trigger element to fill its parent container width */
  fluid: PropTypes.bool,

  /** Adds enter and exit animation */
  animate: PropTypes.bool,

  /** Scrolls to the selected option when dropdown is opened */
  focusOnSelectedOption: PropTypes.bool,

  /** Specifies whether lazy loading of the dropdown items is enabled */
  infiniteScroll: PropTypes.bool,

  /** Defines a callback function which is called on a request to render more list items */
  loadMore: PropTypes.func,

  /** Specifies whether there are more items to load */
  hasMore: PropTypes.bool,

  /** Scrolls to the specified option when dropdown is opened */
  focusOnOption: PropTypes.number
});

_defineProperty(DropdownBase, "defaultProps", {
  placement: 'bottom',
  appendTo: 'parent',
  showArrow: false,
  maxHeight: '260px',
  fluid: false,
  animate: false,
  onShow: function onShow() {},
  onHide: function onHide() {}
});

export default DropdownBase;