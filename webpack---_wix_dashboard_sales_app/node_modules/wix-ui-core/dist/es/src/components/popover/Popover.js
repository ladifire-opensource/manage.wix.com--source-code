import { __assign, __extends, __spreadArrays } from "tslib";
import * as React from 'react';
import { ClickOutside } from '../click-outside';
import { Manager, Reference, Popper } from 'react-popper';
import { CSSTransition } from 'react-transition-group';
import { Portal } from 'react-portal';
import { st, classes } from './Popover.st.css';
import { createModifiers } from './modifiers';
import { filterDataProps } from '../../utils/filter-data-props';
var uniqueId = require('lodash/uniqueId');
import { buildChildrenObject, createComponentThatRendersItsChildren, } from '../../utils';
import { PopoverContext } from './PopoverContext';
import { popoverTestUtils } from './helpers';
import { getAppendToElement } from './utils/getAppendToElement';
import classNames from 'classnames';
// This is here and not in the test setup because we don't want consumers to need to run it as well
var testId;
var isTestEnv = process.env.NODE_ENV === 'test';
if (isTestEnv && typeof document !== 'undefined' && !document.createRange) {
    popoverTestUtils.createRange();
}
var attachClasses = function (node, classnames) {
    var _a;
    return node && (_a = node.classList).add.apply(_a, classnames.split(' '));
};
var detachClasses = function (node, classnames) {
    var _a;
    return node && (_a = node.classList).remove.apply(_a, classnames.split(' '));
};
var shouldAnimatePopover = function (_a) {
    var timeout = _a.timeout;
    if (typeof timeout === 'object') {
        var enter = timeout.enter, exit = timeout.exit;
        return (typeof enter !== 'undefined' &&
            typeof exit !== 'undefined' &&
            (enter > 0 || exit > 0));
    }
    return !!timeout;
};
var getArrowShift = function (shift, direction) {
    if (!shift && !isTestEnv) {
        return {};
    }
    if (direction.startsWith('top') || direction.startsWith('bottom')) {
        return { left: shift + "px" };
    }
    if (direction.startsWith('left') || direction.startsWith('right')) {
        return { top: shift + "px" };
    }
    // Arrow can't be shifted when using automatic positioning
    return {};
};
/**
 * Popover
 */
var Popover = /** @class */ (function (_super) {
    __extends(Popover, _super);
    function Popover(props) {
        var _this = _super.call(this, props) || this;
        _this.targetRef = null;
        _this.portalNode = null;
        _this.appendToNode = null;
        _this.clickOutsideRef = null;
        _this.popperScheduleUpdate = null;
        // Timer instances for the show/hide delays
        _this._hideTimeout = null;
        _this._showTimeout = null;
        _this._handleClickOutside = function (event) {
            var _a = _this.props, onClickOutsideCallback = _a.onClickOutside, shown = _a.shown, disableClickOutsideWhenClosed = _a.disableClickOutsideWhenClosed;
            if (onClickOutsideCallback && !(disableClickOutsideWhenClosed && !shown)) {
                onClickOutsideCallback(event);
            }
        };
        _this._onKeyDown = function (e) {
            var onEscPress = _this.props.onEscPress;
            if (onEscPress && e.key === 'Escape') {
                onEscPress(e);
            }
        };
        /**
         * Checks to see if the focused element is outside the Popover content
         */
        _this._onDocumentKeyUp = function (e) {
            var onTabOut = _this.props.onTabOut;
            if (typeof document !== 'undefined' &&
                _this.popoverContentRef.current &&
                !_this.popoverContentRef.current.contains(document.activeElement)) {
                onTabOut(e);
            }
        };
        _this.state = {
            isMounted: false,
            shown: props.shown || false,
        };
        if (isTestEnv) {
            testId = popoverTestUtils.generateId();
        }
        _this.clickOutsideRef = React.createRef();
        _this.popoverContentRef = React.createRef();
        _this.clickOutsideClass = uniqueId('clickOutside');
        _this.contentHook = "popover-content-" + (props['data-hook'] || '') + "-" + testId;
        return _this;
    }
    Popover.prototype.focus = function () {
        if (this.popoverContentRef.current) {
            this.popoverContentRef.current.focus();
        }
    };
    Popover.prototype.getPopperContentStructure = function (childrenObject) {
        var _this = this;
        var shown = this.state.shown;
        var _a = this.props, moveBy = _a.moveBy, appendTo = _a.appendTo, placement = _a.placement, showArrow = _a.showArrow, moveArrowTo = _a.moveArrowTo, flip = _a.flip, fixed = _a.fixed, customArrow = _a.customArrow, role = _a.role, id = _a.id, zIndex = _a.zIndex, minWidth = _a.minWidth, maxWidth = _a.maxWidth, width = _a.width, dynamicWidth = _a.dynamicWidth, _b = _a.excludeClass, excludeClass = _b === void 0 ? this.clickOutsideClass : _b, contentClassName = _a.contentClassName, onEscPress = _a.onEscPress, tabIndex = _a.tabIndex, ariaLabel = _a["aria-label"], ariaLabelledby = _a["aria-labelledby"], ariaDescribedBy = _a["aria-describedby"];
        var shouldAnimate = shouldAnimatePopover(this.props);
        var modifiers = createModifiers({
            minWidth: minWidth,
            width: width,
            dynamicWidth: dynamicWidth,
            moveBy: moveBy,
            appendTo: appendTo,
            shouldAnimate: shouldAnimate,
            flip: flip,
            placement: placement,
            fixed: fixed,
            isTestEnv: isTestEnv,
        });
        var popper = (React.createElement(Popper, { modifiers: modifiers, placement: placement }, function (_a) {
            var ref = _a.ref, popperStyles = _a.style, popperPlacement = _a.placement, arrowProps = _a.arrowProps, scheduleUpdate = _a.scheduleUpdate;
            _this.popperScheduleUpdate = scheduleUpdate;
            return (React.createElement(PopoverContext.Consumer, null, function (_a) {
                var _b;
                var excludeClickOutsideClasses = _a.excludeClickOutsideClasses;
                return (React.createElement("div", { ref: ref, "data-hook": "popover-content", "data-content-element": _this.contentHook, style: __assign(__assign({}, popperStyles), { zIndex: zIndex, maxWidth: maxWidth }), "data-placement": popperPlacement || placement, className: classNames.apply(void 0, __spreadArrays([classes.popover,
                        _this.clickOutsideClass,
                        contentClassName, (_b = {},
                            _b[classes.withArrow] = showArrow,
                            _b[classes.popoverContent] = !showArrow,
                            _b)], excludeClickOutsideClasses)) },
                    showArrow &&
                        _this.renderArrow(arrowProps, moveArrowTo, popperPlacement || placement, customArrow),
                    React.createElement("div", { key: "popover-content", id: id, role: role, tabIndex: tabIndex, ref: _this.popoverContentRef, className: showArrow ? classes.popoverContent : '', onKeyDown: shown && onEscPress ? _this._onKeyDown : undefined, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, "aria-describedby": ariaDescribedBy },
                        React.createElement(PopoverContext.Provider, { value: {
                                excludeClickOutsideClasses: __spreadArrays([
                                    excludeClass
                                ], excludeClickOutsideClasses),
                            } }, childrenObject.Content))));
            }));
        }));
        return this.wrapWithAnimations(popper);
    };
    Popover.prototype.applyStylesToPortaledNode = function () {
        var shown = this.state.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        if (shouldAnimate || shown) {
            attachClasses(this.portalNode, this.portalClasses);
        }
        else {
            detachClasses(this.portalNode, this.portalClasses);
        }
    };
    Popover.prototype.wrapWithAnimations = function (popper) {
        var _this = this;
        var timeout = this.props.timeout;
        var shown = this.state.shown;
        var shouldAnimate = shouldAnimatePopover(this.props);
        return shouldAnimate ? (React.createElement(CSSTransition, { in: shown, timeout: timeout, unmountOnExit: true, classNames: {
                enter: classes['popoverAnimation-enter'],
                enterActive: classes['popoverAnimation-enter-active'],
                exit: classes['popoverAnimation-exit'],
                exitActive: classes['popoverAnimation-exit-active'],
            }, onExited: function () { return detachClasses(_this.portalNode, _this.portalClasses); } }, popper)) : (popper);
    };
    Popover.prototype.renderPopperContent = function (childrenObject) {
        var popper = this.getPopperContentStructure(childrenObject);
        return this.portalNode ? (React.createElement(Portal, { node: this.portalNode }, popper)) : (popper);
    };
    Popover.prototype.renderArrow = function (arrowProps, moveArrowTo, placement, customArrow) {
        var commonProps = {
            ref: arrowProps.ref,
            key: 'popover-arrow',
            'data-hook': 'popover-arrow',
            style: __assign(__assign({}, arrowProps.style), getArrowShift(moveArrowTo, placement)),
        };
        if (customArrow) {
            return customArrow(placement, commonProps);
        }
        return React.createElement("div", __assign({}, commonProps, { className: classes.arrow }));
    };
    Popover.prototype.componentDidMount = function () {
        var _a = this.props, shown = _a.shown, onTabOut = _a.onTabOut;
        this.initAppendToNode();
        if (onTabOut && shown) {
            this._setBlurByKeyboardListener();
        }
        this.setState({ isMounted: true });
    };
    Popover.prototype._setBlurByKeyboardListener = function () {
        if (typeof document !== 'undefined') {
            document.addEventListener('keyup', this._onDocumentKeyUp, true);
        }
    };
    Popover.prototype._removeBlurListener = function () {
        if (typeof document !== 'undefined') {
            document.removeEventListener('keyup', this._onDocumentKeyUp, true);
        }
    };
    Popover.prototype.initAppendToNode = function () {
        var appendTo = this.props.appendTo;
        this.appendToNode = getAppendToElement(appendTo, this.targetRef);
        if (this.appendToNode) {
            this.portalNode = document.createElement('div');
            this.portalNode.setAttribute('data-hook', 'popover-portal');
            /**
             * reset overlay wrapping layer
             * so that styles from copied classnames
             * won't break the overlay:
             * - content is position relative to body
             * - overlay layer is hidden
             */
            Object.assign(this.portalNode.style, {
                position: 'static',
                top: 0,
                left: 0,
                width: 0,
                height: 0,
            });
            this.appendToNode.appendChild(this.portalNode);
        }
    };
    Popover.prototype.hidePopover = function () {
        var _this = this;
        var isMounted = this.state.isMounted;
        var _a = this.props, hideDelay = _a.hideDelay, onTabOut = _a.onTabOut;
        if (!isMounted || this._hideTimeout) {
            return;
        }
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
        if (onTabOut) {
            this._removeBlurListener();
        }
        if (hideDelay) {
            this._hideTimeout = setTimeout(function () {
                _this.setState({ shown: false });
            }, hideDelay);
        }
        else {
            this.setState({ shown: false });
        }
    };
    Popover.prototype.showPopover = function () {
        var _this = this;
        var isMounted = this.state.isMounted;
        var _a = this.props, showDelay = _a.showDelay, onTabOut = _a.onTabOut;
        if (!isMounted || this._showTimeout) {
            return;
        }
        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        if (onTabOut) {
            this._setBlurByKeyboardListener();
        }
        if (showDelay) {
            this._showTimeout = setTimeout(function () {
                _this.setState({ shown: true });
            }, showDelay);
        }
        else {
            this.setState({ shown: true });
        }
    };
    Popover.prototype.componentWillUnmount = function () {
        if (this.portalNode && this.appendToNode.children.length) {
            // FIXME: What if component is updated with a different appendTo? It is a far-fetched use-case,
            // but we would need to remove the portaled node, and created another one.
            this.appendToNode.removeChild(this.portalNode);
        }
        this.portalNode = null;
        if (this._hideTimeout) {
            clearTimeout(this._hideTimeout);
            this._hideTimeout = null;
        }
        if (this._showTimeout) {
            clearTimeout(this._showTimeout);
            this._showTimeout = null;
        }
    };
    Popover.prototype.updatePosition = function () {
        if (this.popperScheduleUpdate) {
            this.popperScheduleUpdate();
        }
    };
    Popover.prototype.componentDidUpdate = function (prevProps) {
        var shown = this.props.shown;
        if (this.portalNode) {
            // Re-calculate the portal's styles
            this.portalClasses = st(classes.root, this.props.className);
            // Apply the styles to the portal
            this.applyStylesToPortaledNode();
        }
        // Update popover visibility
        if (prevProps.shown !== shown) {
            if (shown) {
                this.showPopover();
            }
            else {
                this.hidePopover();
            }
        }
        else {
            // Update popper's position
            this.updatePosition();
        }
    };
    Popover.prototype.render = function () {
        var _this = this;
        var _a = this.props, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, onKeyDown = _a.onKeyDown, onClick = _a.onClick, children = _a.children, style = _a.style, id = _a.id, excludeClass = _a.excludeClass, fluid = _a.fluid;
        var _b = this.state, isMounted = _b.isMounted, shown = _b.shown;
        var childrenObject = buildChildrenObject(children, {
            Element: null,
            Content: null,
        });
        var shouldAnimate = shouldAnimatePopover(this.props);
        var shouldRenderPopper = isMounted && (shouldAnimate || shown);
        return (React.createElement(Manager, null,
            React.createElement(ClickOutside, { rootRef: this.clickOutsideRef, onClickOutside: shown ? this._handleClickOutside : undefined, excludeClass: [this.clickOutsideClass, excludeClass] },
                React.createElement("div", __assign({ ref: this.clickOutsideRef, style: style, "data-content-hook": this.contentHook, className: st(classes.root, { fluid: fluid }, this.props.className), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, id: id }, filterDataProps(this.props)),
                    React.createElement(Reference, { innerRef: function (r) { return (_this.targetRef = r); } }, function (_a) {
                        var ref = _a.ref;
                        return (React.createElement("div", { ref: ref, className: classes.popoverElement, "data-hook": "popover-element", onClick: onClick, onKeyDown: onKeyDown }, childrenObject.Element));
                    }),
                    shouldRenderPopper && this.renderPopperContent(childrenObject)))));
    };
    Popover.displayName = 'Popover';
    Popover.defaultProps = {
        flip: true,
        fixed: false,
        zIndex: 1000,
    };
    Popover.Element = createComponentThatRendersItsChildren('Popover.Element');
    Popover.Content = createComponentThatRendersItsChildren('Popover.Content');
    return Popover;
}(React.Component));
export { Popover };
//# sourceMappingURL=Popover.js.map