import { __assign, __awaiter, __generator } from "tslib";
import axios from 'axios';
import { buildOptions } from './options';
import { HttpError } from './error';
import { silent, isHttpMockServerEnabled, extractProp, resolveHost, getGlobalConfig, } from './utils';
import { NO_SCENARIO_FOUND, SSR_HOST } from './constants';
import { isNode } from './env-util';
import { requestIdOrEmptyString } from './headers';
var HttpClient = /** @class */ (function () {
    function HttpClient(opts) {
        if (opts === void 0) { opts = {}; }
        this.opts = opts;
        this.opts = defaultClientOptions(this.opts);
        this.client = axios.create(this.opts);
    }
    HttpClient.prototype.request = function (requestOptionsOrFactory) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var host, requestOptions, signedInstance, options;
            var _this = this;
            return __generator(this, function (_c) {
                host = resolveHost(this.opts);
                requestOptions = typeof requestOptionsOrFactory === 'function'
                    ? requestOptionsOrFactory({ isSSR: this.opts.isSSR, host: host })
                    : requestOptionsOrFactory;
                signedInstance = ((_b = (_a = this.opts).getAppToken) === null || _b === void 0 ? void 0 : _b.call(_a)) || '';
                options = buildOptions(requestOptions, host, { signedInstance: signedInstance, csrf: false /* axios handles xsrf */ }, getGlobalConfig());
                if (this.opts.isSSR) {
                    options.baseURL = "http://" + SSR_HOST;
                }
                return [2 /*return*/, this.client
                        .request(options)
                        .catch(function (err) {
                        return _this.maybeFallbackRequest(err, requestOptions, host, signedInstance);
                    })
                        .catch(function (err) { return _this.handleRequestError(err, options); })
                        .then(function (res) { return _this.transformResponse(res, requestOptions); })];
            });
        });
    };
    HttpClient.prototype.get = function (url, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url, method: 'GET' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.delete = function (url, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url, method: 'DELETE' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.head = function (url, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url, method: 'HEAD' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.options = function (url, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url, method: 'OPTIONS' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.post = function (url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url,
                    data: data, method: 'POST' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.put = function (url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url,
                    data: data, method: 'PUT' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.patch = function (url, data, requestOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var opts;
            return __generator(this, function (_a) {
                opts = __assign(__assign({}, requestOptions), { url: url,
                    data: data, method: 'PATCH' });
                return [2 /*return*/, this.request(opts)];
            });
        });
    };
    HttpClient.prototype.handleRequestError = function (err, requestOptions) {
        var requestError = new HttpError(err);
        silent(function () { var _a; return (_a = requestOptions.onError) === null || _a === void 0 ? void 0 : _a.call(requestOptions, requestError); });
        throw requestError;
    };
    HttpClient.prototype.maybeFallbackRequest = function (err, requestOptions, host, signedInstance) {
        var _a;
        if (isHttpMockServerEnabled() &&
            ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 404 &&
            err.response.data === NO_SCENARIO_FOUND) {
            var prodOptions = buildOptions(requestOptions, host, {
                signedInstance: signedInstance,
            });
            return this.client.request(prodOptions);
        }
        throw err;
    };
    HttpClient.prototype.transformResponse = function (res, requestOptions) {
        var requestId = requestIdOrEmptyString(res);
        var data = transformData(res, requestOptions);
        return __assign(__assign({}, res), { data: data,
            requestId: requestId });
    };
    HttpClient.CancelToken = axios.CancelToken;
    HttpClient.isCancel = axios.isCancel;
    return HttpClient;
}());
export { HttpClient };
function defaultClientOptions(opts) {
    var adapter;
    var useHttpAdapter = isNode();
    // https://github.com/webpack/webpack/issues/5939#issue-272316127
    if (useHttpAdapter) {
        var requireFunc = typeof __webpack_require__ === 'function'
            ? __non_webpack_require__
            : require;
        adapter = requireFunc('axios/lib/adapters/http');
    }
    return __assign({ adapter: adapter, isSSR: false }, opts);
}
function transformData(res, requestOptions) {
    var resData = res.data;
    if (requestOptions._pickResponseBody) {
        resData = extractProp(res.data, requestOptions._pickResponseBody);
    }
    if (requestOptions._logs) {
        var logs = extractProp(res.data, requestOptions._logs);
        if (logs === null || logs === void 0 ? void 0 : logs.length) {
            logs.map(function (log) { return console.log.apply(console, log); });
        }
    }
    return resData;
}
//# sourceMappingURL=http-client.js.map