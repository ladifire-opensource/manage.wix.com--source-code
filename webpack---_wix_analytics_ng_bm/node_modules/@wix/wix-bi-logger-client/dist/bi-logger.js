'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('./assert');

var _require = require('./utils/collections'),
    mapValues = _require.mapValues,
    filterValues = _require.filterValues;

var promise = require('./utils/promise');
var log = require('./utils/log');
var EventBuffer = require('./utils/event-buffer');

var BiLogger = function () {
  //TODO: validate args
  function BiLogger(options, context) {
    _classCallCheck(this, BiLogger);

    this._publishers = options.publishers;
    this._validators = options.validators || [];
    this._defaults = options.defaults;
    this._events = options.events || {};
    this._context = context || {};
    this._defaultValueTimeout = options.defaultValueTimeout || 5000;
    this._defaultContinueOnFail = options.defaultContinueOnFail || false;
    this._onPublisherFailHandler = options.onPublisherFailHandler || BiLogger._defaultPublisherFailHandler;
  }

  _createClass(BiLogger, [{
    key: 'log',
    value: function log(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
      var _this = this;

      assert.defined(eventOrKey, 'Event object or event key must be provided.');

      var _extractEventAndConte = this._extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined),
          event = _extractEventAndConte.event,
          context = _extractEventAndConte.context;

      var useBatch = typeof context.useBatch !== 'undefined' ? context.useBatch : this._context.useBatch;

      if (useBatch) {
        var buffer = this._initBuffer(useBatch);

        var dynamicDefaults = filterValues(this._defaults, function (v) {
          return typeof v === 'function';
        });
        var resolvedDefaults = mapValues(dynamicDefaults, function (v) {
          return v();
        });

        return buffer.feed(Object.assign({}, event, resolvedDefaults), context);
      }

      return this._getDefaults().then(function (defaults) {
        var fullEvent = Object.assign({}, defaults, event);

        var validatorsResult = _this._validators.length === 0 ? true : _this._validators.some(function (validator) {
          return validator.match(fullEvent) && (validator.execute(fullEvent) || true);
        });

        if (!validatorsResult) {
          throw new Error('No validator accepted the event. Source: ' + fullEvent.src + ' Evid: ' + (fullEvent.evid || fullEvent.evtId));
        }

        return _this._send(fullEvent, context);
      });
    }
  }, {
    key: 'flush',
    value: function flush() {
      if (!this._buffer) {
        return Promise.resolve();
      }
      return this._buffer.flush();
    }
  }, {
    key: '_send',
    value: function _send(payload) {
      var _this2 = this;

      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return Promise.all(this._publishers.map(function (publisher) {
        var cloned = Object.assign({}, payload);

        return Promise.resolve().then(function () {
          return publisher(cloned, Object.assign({}, _this2._context, context));
        }).catch(function (error) {
          return _this2._onPublisherFailHandler(error, { publisherName: publisher.name, payload: payload });
        });
      })).then(function () {
        return undefined;
      });
    }
  }, {
    key: '_extractEventAndContext',
    value: function _extractEventAndContext(eventOrKey, eventOrContextOrUndefined, contextOrUndefined) {
      var event = void 0;
      var context = {};

      if (typeof eventOrKey !== 'string') {
        event = eventOrKey;
        context = eventOrContextOrUndefined || context;
      } else {
        event = this._events[eventOrKey];

        if (!event) {
          throw new assert.AssertionError('Event with key \'' + eventOrKey + '\' not found in event map.');
        }

        if (eventOrContextOrUndefined) {
          event = Object.assign({}, event, eventOrContextOrUndefined);
          context = contextOrUndefined || context;
        }
      }

      return { event: event, context: context };
    }
  }, {
    key: '_initBuffer',
    value: function _initBuffer(useBatch) {
      var _this3 = this;

      var debounceMs = useBatch === true ? 300 : useBatch;

      return this._buffer || (this._buffer = new EventBuffer(debounceMs).onFlush(function (batchPayload) {
        var staticDefaults = filterValues(_this3._defaults, function (v) {
          return typeof v !== 'function';
        });
        batchPayload.g = staticDefaults;

        return _this3._send(batchPayload, { useBatch: useBatch });
      }));
    }
  }, {
    key: '_handleDefaultsError',
    value: function _handleDefaultsError(err) {
      if (this._defaultContinueOnFail) {
        log.error(err);
        return null;
      }
      return Promise.reject(err);
    }
  }, {
    key: '_getDefaults',
    value: function _getDefaults() {
      var _this4 = this;

      if (!this._defaults) {
        return Promise.resolve({});
      }

      var promises = mapValues(this._defaults, function (value, key) {
        if (typeof value === 'function') {
          try {
            value = value();
          } catch (err) {
            return _this4._handleDefaultsError(err);
          }
        }

        if (value && typeof value.then === 'function') {
          return promise.timedPromise(value, {
            message: 'Cannot get default value \'' + key + ' for BI Event\'',
            timeout: _this4._defaultValueTimeout
          }).catch(function (err) {
            return _this4._handleDefaultsError(err);
          });
        }

        return value;
      });

      return promise.allAsObject(promises);
    }
  }], [{
    key: '_defaultPublisherFailHandler',
    value: function _defaultPublisherFailHandler(error, _ref) {
      var publisherName = _ref.publisherName;

      return publisherName; // do nothing
    }
  }]);

  return BiLogger;
}();

module.exports = BiLogger;
//# sourceMappingURL=bi-logger.js.map