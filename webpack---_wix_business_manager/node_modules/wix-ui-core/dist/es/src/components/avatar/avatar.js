import { __assign, __extends, __rest } from "tslib";
import * as React from 'react';
import classNames from 'classnames';
import { withFocusable } from '../../hocs/Focusable/FocusableHOC';
import { st, classes } from './avatar.st.css';
import { nameToInitials } from './util';
import { filterDataProps } from '../../utils/filter-data-props';
var DEFAULT_CONTENT_TYPE = 'placeholder';
/**
 * Avatar is a type of element that visually represents a user, either as an image, placeholder or text.
 *
 * <p>There are 3 props for corresponding content types: `text`, `placeholder` and `imgProps`.
 * If more than one of these props is supplied (with `name` prop giving default value to the `text` prop),
 * then the resolved content type for display goes according to this priority: image -> text -> placeholder.
 */
var AvatarComponent = /** @class */ (function (_super) {
    __extends(AvatarComponent, _super);
    function AvatarComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { imgLoaded: false };
        _this.loadImg = function () {
            _this.img = new Image();
            _this.img.onload = function () {
                // don't set state after unmount
                _this.img && _this.setState({ imgLoaded: true });
            };
            _this.img.src = _this.props.imgProps.src;
        };
        _this.unloadImg = function () {
            // TODO: Is this necessary? It is taken from https://github.com/mbrevda/react-image/blob/c402ed3f5d54b88e51eca3326a1e81d964995795/src/index.js#L146
            delete _this.img.onload;
            try {
                delete _this.img.src;
            }
            catch (e) {
                // On Safari in Strict mode this will throw an exception,
                //  - https://github.com/mbrevda/react-image/issues/187
                // We don't need to do anything about it.
            }
            delete _this.img;
        };
        _this._handleKeyDown = function (event) {
            if (event.key === ' ' || event.key === 'Enter' || event.key === 'Space') {
                event.preventDefault();
                _this.props.onClick();
            }
        };
        return _this;
    }
    /** This is the resolved content type the consumer wants to display */
    AvatarComponent.prototype.getRequestedContentType = function (props) {
        var name = props.name, text = props.text, placeholder = props.placeholder, imgProps = props.imgProps;
        return imgProps && imgProps.src
            ? 'image'
            : text || name
                ? 'text'
                : placeholder
                    ? 'placeholder'
                    : DEFAULT_CONTENT_TYPE;
    };
    /** This is content type that will be displayed. (If img is loading then this will be the fallback) */
    AvatarComponent.prototype.getCurrentContentType = function () {
        var requestedType = this.getRequestedContentType(this.props);
        if (requestedType === 'image' && !this.state.imgLoaded) {
            var _a = this.props, name_1 = _a.name, text = _a.text, placeholder = _a.placeholder;
            return text || name_1
                ? 'text'
                : placeholder
                    ? 'placeholder'
                    : DEFAULT_CONTENT_TYPE;
        }
        return requestedType;
    };
    AvatarComponent.prototype.componentDidMount = function () {
        this.getRequestedContentType(this.props) === 'image' &&
            !this.state.imgLoaded &&
            this.loadImg();
    };
    AvatarComponent.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        if (!nextProps.imgProps ||
            !this.props.imgProps ||
            nextProps.imgProps.src !== this.props.imgProps.src) {
            this.setState({ imgLoaded: false });
            this.img && this.unloadImg();
        }
    };
    AvatarComponent.prototype.componentDidUpdate = function () {
        this.getRequestedContentType(this.props) === 'image' &&
            !this.img &&
            !this.state.imgLoaded &&
            this.loadImg();
    };
    AvatarComponent.prototype.componentWillUnmount = function () {
        this.img && this.unloadImg();
    };
    AvatarComponent.prototype.render = function () {
        var _a = this.props, name = _a.name, title = _a.title, ariaLabel = _a.ariaLabel, onClick = _a.onClick, focusableOnFocus = _a.focusableOnFocus, focusableOnBlur = _a.focusableOnBlur;
        var contentType = this.getCurrentContentType();
        var focusProps = !!onClick && {
            role: 'button',
            onFocus: focusableOnFocus,
            onBlur: focusableOnBlur,
            onKeyDown: this._handleKeyDown,
            tabIndex: 0,
        };
        return (React.createElement("div", __assign({ "data-content-type": contentType, "data-img-loaded": this.state.imgLoaded, title: title || name, "aria-label": ariaLabel || name, onClick: onClick }, focusProps, { className: st(classes.root, {
                imgLoaded: this.state.imgLoaded,
                contentType: contentType,
            }, this.props.className) }, filterDataProps(this.props)), this.getContent(contentType)));
    };
    AvatarComponent.prototype.getContent = function (contentType) {
        switch (contentType) {
            case 'text': {
                var _a = this.props, name_2 = _a.name, text = _a.text;
                var textContent = text || nameToInitials(name_2, this.props.initialsLimit);
                return (React.createElement("div", { className: classes.content, "data-hook": "text-container" }, textContent));
            }
            case 'placeholder': {
                var placeholder = this.props.placeholder;
                return placeholder === null
                    ? null
                    : React.cloneElement(placeholder, {
                        className: classNames(placeholder.props.className, classes.content),
                    });
            }
            case 'image': {
                var _b = this.props.imgProps, alt = _b.alt, className = _b.className, rest = __rest(_b, ["alt", "className"]);
                return (React.createElement("img", __assign({ className: classNames(classes.content, className), alt: alt ? alt : this.props.name }, rest)));
            }
            default: {
                return null;
            }
        }
    };
    AvatarComponent.displayName = 'Avatar';
    AvatarComponent.defaultProps = {
        placeholder: null,
    };
    return AvatarComponent;
}(React.Component));
export { AvatarComponent };
export var Avatar = withFocusable(AvatarComponent);
//# sourceMappingURL=avatar.js.map