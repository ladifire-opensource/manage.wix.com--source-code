import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["size", "presence", "indication", "color", "customIndication", "onIndicationClick", "dataHook", "className", "shape", "text", "placeholder", "name", "onClick", "showIndicationOnHover", "loading"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import React from 'react';
import PropTypes from 'prop-types';
import IconButton from '../IconButton';
import { avatarShapes, dataHooks } from './constants';
import { Avatar as CoreAvatar } from "wix-ui-core/dist/es/src/components/avatar";
import Loader from '../Loader';
import { placeholderSVGs } from './assets';
import { st, classes } from './Avatar.st.css';
import { capitalize } from '../utils/cssClassUtils';
import stringToColor from './string-to-color';
import { FontUpgradeContext } from '../FontUpgrade/context';

var getSizeNumber = function getSizeNumber(size) {
  return Number(size.substring(4));
};

var defaultSize = 48;
var minSmallIconButton = 60;
/**
 * Avatar is a type of element that visually represents a user, either as an image, name initials or placeholder icon.
 */

var Avatar = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(Avatar, _React$PureComponent);

  var _super = _createSuper(Avatar);

  function Avatar(props) {
    var _this;

    _classCallCheck(this, Avatar);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_onMouseEnter", function () {
      if (_this.props.showIndicationOnHover) {
        _this.setState({
          showIndication: true
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onMouseLeave", function () {
      if (_this.props.showIndicationOnHover) {
        _this.setState({
          fadeIndication: true
        });

        setTimeout(function () {
          return _this.setState({
            fadeIndication: false,
            showIndication: false
          });
        }, 150);
      }
    });

    _this.state = {
      fadeIndication: false,
      showIndication: false
    };
    return _this;
  }

  _createClass(Avatar, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          size = _this$props.size,
          presence = _this$props.presence,
          indication = _this$props.indication,
          color = _this$props.color,
          customIndication = _this$props.customIndication,
          onIndicationClick = _this$props.onIndicationClick,
          dataHook = _this$props.dataHook,
          className = _this$props.className,
          shape = _this$props.shape,
          text = _this$props.text,
          placeholder = _this$props.placeholder,
          name = _this$props.name,
          onClick = _this$props.onClick,
          showIndicationOnHover = _this$props.showIndicationOnHover,
          loading = _this$props.loading,
          rest = _objectWithoutProperties(_this$props, _excluded);

      var _this$state = this.state,
          fadeIndication = _this$state.fadeIndication,
          showIndication = _this$state.showIndication;
      var calculatedColor = color || stringToColor(text || name); // if color is provided as a prop use it, otherwise, generate a color based on the text

      var sizeNumber = getSizeNumber(size);
      var renderOnHover = !showIndicationOnHover || showIndication;
      var indicationConstraints = renderOnHover && sizeNumber >= defaultSize;
      var renderIndication = indicationConstraints && !customIndication && indication;
      var renderCustomIndication = indicationConstraints && customIndication;
      var renderLoader = loading && sizeNumber >= defaultSize;
      return /*#__PURE__*/React.createElement("div", {
        "data-hook": dataHook,
        className: st(className, classes.root)
      }, /*#__PURE__*/React.createElement(FontUpgradeContext.Consumer, null, function (_ref) {
        var active = _ref.active;
        return /*#__PURE__*/React.createElement("div", {
          "data-hook": dataHooks.avatarWSR,
          onMouseEnter: _this2._onMouseEnter,
          onMouseLeave: _this2._onMouseLeave,
          className: st(classes.avatarContainer, {
            shape: shape,
            size: size,
            indication: Boolean(customIndication || indication),
            presence: Boolean(presence),
            presenceType: presence,
            clickable: !!onClick,
            fade: fadeIndication,
            hasText: !!text
          }),
          "data-madefor": active
        }, /*#__PURE__*/React.createElement("div", {
          className: classes.coreAvatar
        }, /*#__PURE__*/React.createElement(CoreAvatar, _extends({}, _objectSpread(_objectSpread({}, rest), {}, {
          placeholder: placeholder ? placeholder : /*#__PURE__*/React.createElement(AvatarDefaultPlaceholder, {
            shape: shape,
            size: size
          }),
          text: text,
          name: name,
          onClick: onClick,
          initialsLimit: sizeNumber < 30 ? 1 : undefined,
          'data-hook': dataHooks.avatarCore
        }), {
          className: st(classes.avatar, classes["color".concat(capitalize(calculatedColor))])
        }))), renderLoader && [/*#__PURE__*/React.createElement("div", {
          key: "overlay",
          className: st(classes.loaderContainer, classes.overlay)
        }), /*#__PURE__*/React.createElement("div", {
          key: "loader",
          className: st(classes.loaderContainer, classes.loader)
        }, /*#__PURE__*/React.createElement(Loader, {
          dataHook: dataHooks.loader,
          size: "tiny"
        }))], presence && /*#__PURE__*/React.createElement("div", {
          className: classes.presence
        }), renderIndication && /*#__PURE__*/React.createElement("div", {
          className: classes.indication
        }, /*#__PURE__*/React.createElement(IconButton, {
          className: classes.iconButtonShadow,
          dataHook: dataHooks.indication,
          onClick: onIndicationClick,
          skin: "inverted",
          shape: shape,
          size: sizeNumber > minSmallIconButton ? 'small' : 'tiny'
        }, indication)), renderCustomIndication && /*#__PURE__*/React.createElement("div", {
          className: classes.indication,
          "data-hook": dataHooks.customIndication,
          onClick: onIndicationClick
        }, customIndication));
      }));
    }
  }]);

  return Avatar;
}(React.PureComponent);

var AvatarDefaultPlaceholder = function AvatarDefaultPlaceholder(_ref2) {
  var shape = _ref2.shape,
      size = _ref2.size;
  return shape !== avatarShapes.square ? placeholderSVGs[size][avatarShapes.circle] : placeholderSVGs[size][avatarShapes.square];
};

var CoreAvatarPropTypes = {
  /**
   * Defines a name of the avatar user. Text initials will be generated from the name.
   * The name value will be used as default value for HTML title and `aria-label` attributes.
   * And also as default value for the image's alt attribute if `imgProps` is provided.
   */
  name: PropTypes.string,

  /** Defines a text to render as a content instead of a given `name`. */
  text: PropTypes.string,

  /**
   * Accept any content to render as a content placeholder. This placeholder will be displayed if no text, name or imgProps are provided.<br>
   * By default use a generic avatar user icon.
   */
  placeholder: PropTypes.node,

  /** Accept all common `<img>` tag properties. */
  imgProps: PropTypes.object,

  /** Defines a string that labels the current element in case where text label is not visible on the screen. */
  ariaLabel: PropTypes.string,

  /** Defines a standard HTML title attribute value. Applies it to the root element. */
  title: PropTypes.string,

  /** Defines a click event handler. When defined, component will be clickable and will have a pointer cursor on hover. */
  onClick: PropTypes.func
};
Avatar.displayName = 'Avatar';
Avatar.propTypes = _objectSpread(_objectSpread({}, CoreAvatarPropTypes), {}, {
  /** Controls the size of an avatar. */
  size: PropTypes.oneOf(['size90', 'size72', 'size60', 'size48', 'size36', 'size30', 'size24', 'size18']),

  /**
   * Controls the background color of the avatar. If not provided,
   * color is determined by the provided text or name so that each name will receive a different color.
   */
  color: PropTypes.oneOf(['A1', 'A2', 'A3', 'A4', 'A5', 'A6']),

  /** Controls the shape of the image. */
  shape: PropTypes.oneOf(['circle', 'square']),

  /** Specifies a CSS class name to be appended to the componentâ€™s root element. */
  className: PropTypes.string,

  /** Applies a data-hook HTML attribute that can be used in the tests. */
  dataHook: PropTypes.string,

  /** Sets the presence status of an avatar. */
  presence: PropTypes.oneOf(['online', 'offline', 'busy']),

  /** Accept any content to render as an indication item. */
  indication: PropTypes.node,

  /**
   * Accept any content to render as a custom indication item. This indication element will not be wrapped by an IconButton.
   * It could be rendered in other shapes (such as square).
   * */
  customIndication: PropTypes.node,

  /** Defines a callback function which is called every time indication element is clicked. */
  onIndicationClick: PropTypes.func,

  /** Shows indication element on hover. */
  showIndicationOnHover: PropTypes.bool,

  /** Shows a loader on top of an avatar. */
  loading: PropTypes.bool
});
Avatar.defaultProps = {
  size: 'size48',
  shape: 'circle',
  showIndicationOnHover: false
};
export default Avatar;